# 二刷的一些总结

## 链表

### 203 移除链表中的元素：

- 思路

  > 为了保证头节点和其他节点一致，所以加一个虚拟头节点
  >
  > 1. 虚拟头节点的创立，以及初始化
  > 2. 以一个操作节点\*cur 来操作(定义加初始化，也就是说一般一开始以虚拟头节点作为操作节点），虚拟节点要保持不动，这个在创建链表和打印链表的时候都是这样的

  ```cpp
  //1.2.一般是这样的
     ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
     dummyHead->next = head; // 将虚拟头结点指向head，这样方便后面做删除操作
     ListNode* cur = dummyHead;
  ```

  > 3. 删除节点，这里一般是递归，要有 （1）截止条件 （2）真实逻辑（一般要有一个临时节点 temp） (3) 递归调用（比如 cur = cur->next 这种），还有格外注意一点的是在完成逻辑上的指针指向后，也要注意回收内存这件事
  > 4. 重新确认新的头节点 + 虚拟头节点的回收 + 返回头节点

- 需要背过：

```cpp
if (nums.empty()) return nullptr;

  ListNode *head = new ListNode(nums[0]);
  ListNode *cur = head;
  for (int i= 1; i < nums.size(); ++i) {
    cur->next = new ListNode(nums[i]);
    cur = cur->next;
  }
```

- 完整 ACM 代码

```cpp
//leetcode 203. 移除链表元素 ACM格式
#include<iostream>
#include<vector>
using namespace std;

// 定义链表节点
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        // 1.虚拟头节点的创立，以及初始化
        ListNode* temp = new ListNode(0);
        temp->next = head;
        // 2. 以一个操作节点*cur来操作，虚拟节点要保持不动
        ListNode* cur = temp;
        // 3. 删除节点
        while (cur->next != NULL) {
            if (cur->next->val == val) {
                ListNode* tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            } else {
                cur = cur->next;
            }
        }
        // 4. 虚拟头节点的回收以及返回头节点
        head = temp->next;
        delete temp;
        return head;
    }
};

// 创建链表
ListNode* createList(vector<int>& nums) {
    if (nums.empty()) return nullptr;

    ListNode* head = new ListNode(nums[0]);
    ListNode* cur = head;
    for (int i = 1; i < nums.size(); i++) {
        cur->next = new ListNode(nums[i]);
        cur = cur->next;
    }
    return head;
}

// 打印链表
void printList(ListNode* head) {
    if (!head) {
        cout << "[]" << endl;
        return;
    }

    cout << "[";
    ListNode* cur = head;
    while (cur) {
        cout << cur->val;
        if (cur->next) cout << ",";
        cur = cur->next;
    }
    cout << "]" << endl;
}

// 释放链表内存
void deleteList(ListNode* head) {
    while (head) {
        ListNode* tmp = head;
        head = head->next;
        delete tmp;
    }
}

int main() {
    int n, val;
    cout << "请输入链表长度: ";
    cin >> n;

    vector<int> nums(n);
    cout << "请输入链表元素: ";
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }

    cout << "请输入要删除的值: ";
    cin >> val;

    // 创建链表
    ListNode* head = createList(nums);

    cout << "原链表: ";
    printList(head);

    // 删除元素
    Solution solution;
    head = solution.removeElements(head, val);

    cout << "删除值 " << val << " 后的链表: ";
    printList(head);

    // 释放内存
    deleteList(head);

    return 0;
}
```

### 206 翻转链表

- 双指针法
  > 1. 两个指针（其实这里是把之前操作节点 cur 变成两个操作节点），一个指向当前节点 cur，一个指向前一个节点 pre（所以本身也是一个快慢指针），然后不断往后移动，直到当前节点为空，返回前一个节点即可 ` ListNode *cur = head; ListNode *pre = NULL;`
  > 2. 业务处理：一般是递归就得有截止条件，临时节点，递归调用了
  > 3. 重新确认新的头节点 + 虚拟头节点的回收 + 返回头节点

```cpp
class Solution {
public:
//双指针法
    ListNode* reverseList(ListNode* head) {
        ListNode *temp;
        ListNode *cur = head;
        ListNode *pre = NULL;
        while(cur) {
           temp = cur->next;
           cur->next = pre;
           pre = cur;
           cur = temp;
        }
        return pre;
    }
};
```

- 递归法

```cpp
class Solution {
public:
    ListNode *reverse(ListNode *pre, ListNode *cur) {
        //1.截止条件+最后的返回值
        if(cur == NULL) return pre;
        ListNode *temp = cur->next;
        cur->next = pre;
        // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步
        // pre = cur;
        // cur = temp;
        //2.循环调用
        return reverse(cur, temp);
    }

    ListNode* reverseList(ListNode* head) {
        // 和双指针法初始化是一样的逻辑
        // ListNode* cur = head;
        // ListNode* pre = NULL;
        return reverse(NULL, head);
    }
};
```

### 24.两两交换链表中的节点

- 算是一个总结加复习吧:递归法

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        //1. 设置一个虚拟头结点+初始化（->next)
        ListNode *temphead = new ListNode(0);
        temphead->next = head;
        //2. 设置一个操作节点加初始化
        ListNode *cur = temphead;
        //3. 调换逻辑---递归进行
        //（1）.截止条件
        while(cur->next != nullptr && cur->next->next != nullptr) {
            //(2). 逻辑
            ListNode *tmp = cur->next;
            ListNode *tmp1 = cur->next->next->next;

            cur->next = cur->next->next;
            cur->next->next = tmp;
            cur->next->next->next = tmp1;
            //(3). 递归调用
            cur = cur->next->next;
        }
        //4. 重新确认新的头节点 + 虚拟头节点的回收 + 返回头节点
        ListNode *result = temphead->next;
        delete temphead;
        return result;
    }
};
```

### 19.删除链表的倒数第 N 个节点

- 快慢指针
  > 1. 虚拟头节点的创立，以及初始化
  > 2. 两个操作节点快慢指针的创立和初始化
  > 3. 工具逻辑：快指针先走 N+1 步（这里也是个递归），两个操作指针指向的值的差值
  > 4. 工具逻辑：快慢指针同时走，直到快指针走到头（这里也是个递归）
  > 5. 业务处理：一般是递归，删除节点
  > 6. 重新确认新的头节点 + 虚拟头节点的回收 + 返回头节点

```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // 1. 设置一个虚拟头结点+初始化（->next)
        ListNode* temphead = new ListNode(0);
        temphead->next = head;

        ListNode* slow = temphead;
        ListNode* fast = temphead;

        while (n-- && fast != NULL) {
            fast = fast->next;
        }

        fast = fast->next;

        while (fast != NULL) {
            fast = fast->next;
            slow = slow->next;
        }
        // 业务处理
        // slow->next = slow->next->next;
        // 回收内存
        ListNode* tmp = slow->next;
        slow->next = slow->next->next;
        delete tmp;
        return temphead->next;
    }
};
```

### 02.07.链表相交

- 快慢指针

```cpp
class Solution {
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
        while (headA == NULL || headB == NULL) {
            return NULL;
        }

        ListNode* cur1 = headA;
        ListNode* cur2 = headB;

        int len1 = 0, len2 = 0;
        while (cur1 != NULL) {
            len1++;
            cur1 = cur1->next;
        }
        while (cur2 != NULL) {
            len2++;
            cur2 = cur2->next;
        }

        cur1 = headA;
        cur2 = headB;

        if (len1 > len2) {
            for (int i = 0; i < (len1 - len2); ++i) {
                cur1 = cur1->next;
            }
        }
        if (len1 < len2) {
            for (int i = 0; i < (len2 - len1); ++i) {
                cur2 = cur2->next;
            }
        }

        while (cur1 != NULL) {
            if (cur1 == cur2) {
                return cur1;
            }
            cur1 = cur1->next;
            cur2 = cur2->next;
        }
        return NULL;
    }
};
```
