# 遍历二叉树

> 递归遍历

- 递归的截止条件是操作指针指到叶子节点之后就是 NULL 了

```cpp
class Solution {
public:
    void A(TreeNode *cur, vector<int> &vec) {
        if(cur == NULL) return;
        vec.push_back(cur->val);
        A(cur->left, vec);
        A(cur->right, vec);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector <int> result;
        A(root,result);
        return result;
    }
};
```

> 迭代遍历---深度优先

- 因为这里要存留下树的节点，以便以后调用，所以栈是可以保存以前的值的，所以要用栈
- `if(root == NULL) return;`//树的领域，格外注意首先考虑这一点
- 而对于迭代，迭代的终止条件 `while (!st.empty())`栈是否为空

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> a;//操作栈
        vector<int> result;//结果vector,因为结果返回vector<int>
        if(root == NULL) return result;//树的领域，格外注意首先考虑这一点
        //a.push(root->val);//这里不是压入值，而是TreeNode
        a.push(root);
        while(!a.empty()){
           //业务处理
           //中
           TreeNode *node = a.top();
           a.pop();
           result.push_back(node->val);
           if(node->right != NULL) {a.push(node->right);}
           if (node->left) a.push(node->left);
        }
        return result;
    }
};
```

> 对迭代法进行统一

> 层序遍历---广度优先

- 队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。
  `错误的答案`
  > 在向 result 添加元素之前，需要确保 result 的维度足够大。否则，访问 result[num] 会导致未定义行为

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode *> que;
        vector<vector<int>> result;
        if(root == NULL) {
            return result;
        }
        que.push(root);
        que.push(NULL);
        int num = 0;
        while (!que.empty()) {
            if(que.front() != NULL){
            TreeNode *temp = que.front();
            que.pop();
            result[num].push_back(temp->val);
            if(temp->left) que.push(temp->left);
            if(temp->right) que.push(temp->right);
            que.push(NULL);
           } else {
            num++;
           }
        }
        return result;
    }
};
```

`正确的答案`

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        vector<vector<int>> result;
        if (root == NULL) {
            return result;
        }
        que.push(root);
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            ////
            ///这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* temp = que.front();
                que.pop();
                vec.push_back(temp->val);
                if (temp->left)
                    que.push(temp->left);
                if (temp->right)
                    que.push(temp->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

## 226.翻转二叉树

`错误的解法`

> 只是可以改变输出结果，但是这里要求改变树的内部结构

```cppclass Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()) {
            TreeNode* node = st.top();              // 中
            st.pop();
            //swap(node->left, node->right);
            if(node->left) st.push(node->left);     // 左
            if(node->right) st.push(node->right);   // 右

        }
        return root;
    }
};
```

`正确的解法`

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()) {
            TreeNode* node = st.top();              // 中
            st.pop();
            swap(node->left, node->right);//更改的是节点，而不是val
            if(node->right) st.push(node->right);   // 右
            if(node->left) st.push(node->left);     // 左
        }
        return root;
    }
};
```
