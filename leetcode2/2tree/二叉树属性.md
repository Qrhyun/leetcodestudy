## 101 对称二叉树

- 一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。
- 都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了
  `递归法`
- 一般要两个函数，一个专门用作递归，一个是主函数，来传入参数调用递归
- 首先排除空节点的情况
- 递归法

```cpp
class Solution {
public:
    bool compare(TreeNode* left, TreeNode* right) {
        // 首先排除空节点的情况
        if (left == NULL && right != NULL) return false;
        else if (left != NULL && right == NULL) return false;
        else if (left == NULL && right == NULL) return true;
        // 排除了空节点，再排除数值不相同的情况
        else if (left->val != right->val) return false;

        // 此时就是：左右节点都不为空，且数值相同的情况
        // 此时才做递归，做下一层的判断
        bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
        bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
        bool isSame = outside && inside;                    // 左子树：中、 右子树：中 （逻辑处理）
        return isSame;

    }
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        return compare(root->left, root->right);
    }
};
```

`迭代法`

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列

        while (!que.empty()) {  // 接下来就要判断这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }

            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};
```

## 104.二叉树的最大深度

`递归法`

> - 本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。
> - 二叉树节点的深度：指从**根节点到该节点**的最长简单路径边的条数或者节点数（取决于深度从 0 开始还是从 1 开始）
> - 二叉树节点的高度：指从**该节点到叶子节点**的最长简单路径边的条数或者节点数（取决于高度从 0 开始还是从 1 开始）
> - 而根节点的高度就是二叉树的最大深度，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度。

```cpp
class Solution {
public:
    int getdepth(TreeNode *node) {
        if(node == NULL) return 0;
        int leftdepth = getdepth(node->left);
        int rightdepth = getdepth(node->right);
        if(leftdepth >= rightdepth) return leftdepth + 1;
        else return rightdepth+1;
    }
    int maxDepth(TreeNode* root) {
        int result = getdepth(root);
        return result;
    }
};
```

`迭代法`

- 使用迭代法的话，使用层序遍历是最为合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。
- 在二叉树中，一层一层的来遍历二叉树，记录一下遍历的层数就是二叉树的深度

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        int result = 0;
        queue<TreeNode *> que;
        if (root == NULL) return 0;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            result++;
            for(int i = 0; i < size; i++){
                TreeNode *temp = que.front();
                que.pop();
                if(temp->left) que.push(temp->left);
                if(temp->right) que.push(temp->right);
            }
        }
    return result;
    }
};
```

## 111.二叉树的最小深度

`递归法`
`错误答案`

```cpp
class Solution {
public:
    int getdepth(TreeNode *node) {
        if (node == NULL) return 0;
        int leftdepth = getdepth(node->left);
        int rightdepth = getdepth(node->right);
        if(leftdepth <= rightdepth) return leftdepth + 1;
        else return rightdepth + 1;

    }
    int minDepth(TreeNode* root) {
        return getdepth(root);
    }
};
```

- 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。注意是叶子节点。
- 什么是叶子节点，左右孩子都为空的节点才是叶子节点！
- 所以说这里需要加入判断

```cpp
class Solution {
public:
    int getdepth(TreeNode* node) {
        if (node == NULL)
            return 0;
        int leftdepth = getdepth(node->left);
        int rightdepth = getdepth(node->right);

        if (node->left == NULL && node->right != NULL) {
            return 1 + rightdepth;
        }
        if (node->right == NULL && node->left != NULL) {
            return 1 + leftdepth;
        }

        return 1 + min(leftdepth, rightdepth);
    }
    int minDepth(TreeNode* root) { return getdepth(root); }
};
```

`迭代法`

- 需要注意的是，只有当左右孩子都为空的时候，才说明遍历到最低点了。如果其中一个孩子不为空则不是最低点

```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {
        int result = 0;
        queue<TreeNode *> que;
        if (root == NULL) return 0;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            result++;
            for(int i = 0; i < size; i++){
                TreeNode *temp = que.front();
                if(temp->left == NULL && temp->right == NULL){
                   return result;
                }
                que.pop();
                if(temp->left) que.push(temp->left);
                if(temp->right) que.push(temp->right);
            }
        }
    return result;
    }
};
```

## 222.完全二叉树的节点个数

`按照普通二叉树的方法`

```cpp
class Solution
{
public:
  int getcount(TreeNode *node) {
    if (node == NULL) return 0;
    int leftcount  = getcount(node->left);
    int rightcount = getcount(node->right);
    return leftcount+rightcount+1;
  }
  int countNodes(TreeNode *root) {
      return getcount(root);
  }
};
```

`按照完全二叉树的特性`

- 完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。
- 对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为 1。
- 对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况 1 来计算。
- 判断其子树是不是满二叉树，如果是则利用公式计算这个子树（满二叉树）的节点数量，如果不是则继续递归

```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便
        while (left) {  // 求左子树深度
            left = left->left;
            leftDepth++;
        }
        while (right) { // 求右子树深度
            right = right->right;
            rightDepth++;
        }
        if (leftDepth == rightDepth) {
            return (2 << leftDepth) - 1; // 注意(2<<1) 相当于2^2，所以leftDepth初始为0
        }
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

## 110.平衡二叉树

- 代码的逻辑其实是求的根节点的高度，而根节点的高度就是这棵树的最大深度，所以才可以使用后序遍历
- leetcode 的题目中都是以节点为一度，即根节点深度是 1
- 求深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）
- 求的是二叉树的最大深度，也用的是后序遍历。那是因为代码的逻辑其实是求的根节点的高度，而根节点的高度就是这棵树的最大深度，所以才可以使用后序遍历。
- 既然要求比较高度，必然是要后序遍历

```cpp
class Solution {
public:
    //平衡二叉树这里是讨论高度（一定要把握住从底向上的这种概念），以前的深度是讨论深度
    //这里统计高度
    int getHigh(TreeNode *node) {
        if(node == NULL) {
            return 0;
        }
        int leftHigh = getHigh(node->left); //左子树的递归
        if(leftHigh == -1) return -1; //汇聚左子树的结果
        int rightHigh = getHigh(node->right); //右子树的递归
        if(rightHigh == -1) return -1;//汇聚右子树的结果
        else{
        return abs(leftHigh - rightHigh) > 1 ? -1 : 1 + max(leftHigh, rightHigh);
        }
    }
    bool isBalanced(TreeNode* root) {
        return getHigh(root) == -1 ? false : true;
    }
};
```

## 257 二叉树的所有路径

- 所有从根节点到叶子节点的路径。
- 从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。
- 在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一个路径再进入另一个路径。
  `递归+回溯`
- 递归把握：前序遍历（代码编写顺序是中左右），截止条件里面就是业务处理的焦点，然后需要左子树和右子树分别递归
- 回溯一般会和递归一起，递归介素，紧接着就是回溯

```cpp
class Solution {
public:
    void traversal(TreeNode *cur, vector<int> &path, vector<string> &result){
        //中
        path.push_back(cur->val);
        //递归截止条件
        if(cur->left == NULL && cur->right == NULL) {
            string spath;
            for(int i = 0; i < path.size() - 1; i++){
                spath += to_string(path[i]);//这里一定要将int转化为string
                spath += "->";
            }
            spath += to_string(path[path.size() - 1]);
            result.push_back(spath);
            return;
        }
        if(cur->left) {
            //左
            traversal(cur->left, path, result);
            path.pop_back();//回溯
        }
        if(cur->right) {
            //友
            traversal(cur->right, path, result);
            path.pop_back();//回溯
        }
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        vector<int> path;
        if(root == NULL) return result;
        traversal(root, path, result);
        return result;
    }
};
```

## 404.左叶子之和

- 节点 A 的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么 A 节点的左孩子为左叶子节点

```cpp
class Solution {
public:
    //这里采用后序遍历，先统计左子树，再统计右子树，最后汇聚
    int sumOfLeftLeaves(TreeNode* root) {
        if (root == NULL) return 0;//先讨论第一种特殊情况
        if (root->left == NULL && root->right== NULL) return 0; //再讨论第二种特殊情况

        int leftsum = sumOfLeftLeaves(root->left); // 左子树
        if(root->left && !root->left->left && !root->left->right) {
            // 具体的业务处理：左子树就是一个左叶子的情况
            leftsum = root->left->val;
        }
        int rightsum = sumOfLeftLeaves(root->right); // 右子树

        int sum = leftsum + rightsum; // 中，像这里就不用讨论加上中间的节点了。因为第二种特殊情况已经讨论了
        return sum;
    }
};
```

```cpp
class Solution {
public:
    //这里采用后序遍历，先统计左子树，再统计右子树，最后汇聚
    int sumOfLeftLeaves(TreeNode* root) {
       stack<TreeNode *> a;
       if(root == NULL) return 0;
       if (root->left == NULL && root->right== NULL) return 0;
       int sum = 0;
       a.push(root);
       while(!a.empty()){
         TreeNode *temp = a.top();
         a.pop();
         //中。迭代的终止条件
         if(temp->left != NULL && temp->left->left == NULL && temp->left->right == NULL){
            sum  += temp->left->val;
         }
         //左 。压栈
         if(temp->left) {
            a.push(temp->left);
         }
         //右。 压栈
         if(temp->right) {
            a.push(temp->right);
         }
       }
       return sum;
    }
};
```

## 513.找树左下角的值

- 首先要是最后一行，然后是最左边的值
- 利用 a 的不断赋值，就能得到最后的值
- 注意为什么要用层序遍历，因为本题刻意强调最后一行，行的概念就用层序遍历，用队列
  `递归回溯法`

```cpp
class Solution {
public:
    int maxDepth = INT_MIN;
    int result;
    void traversal(TreeNode *root, int depth) {
        //递归的截止条件,中
         if(root->left == NULL && root->right == NULL){
            if(depth > maxDepth) {
                maxDepth = depth;
                result = root->val;
            }
            return;
         }

        //左, 迭代，这里左迭代在右迭代前面。所以这是可以保证第一个节点
        if(root->left) {
            depth++;
            traversal(root->left, depth);
            depth--;//回溯
        }

        //右, 迭代
        if(root->right) {
            depth++;
            traversal(root->right, depth);
            depth--;//回溯
        }
        return;
    }
    int findBottomLeftValue(TreeNode* root) {
        traversal(root, 0);
        return result;
    }
};
```

`迭代`

```cpp
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
       queue<TreeNode *> que;
       int r = 0;
       que.push(root);
       while(!que.empty()) {
        int size = que.size();
        r = que.front()->val;
        for(int i = 0; i < size; i++) {
            TreeNode *node = que.front();
            que.pop();
            if (node->left) que.push(node->left);
            if (node->right) que.push(node->right);
        }
       }
       return r;
    }
};
```

## 112.路径总和
`递归回溯法`
- 注意这里传入的参数为`targetSum - root->val`，当某些变量放在前面声明也不行，放在后面声明也不行，可以考虑减法减数
- 注意这里每次加的都是`cur->left->val`，而不是`root->val`，因为为了中节点时候进行遍历
- 注意这里每次回溯都会进行判断，并返回true，是为了注意退出的层级，里面判断了true,要传递到外面
```cpp
class Solution {
private:
    int sum = 0;
    bool traversal(TreeNode *cur, int count) {
        if(cur->left == NULL && cur->right == NULL) {
           if(sum == count) {
            return true;
           }
        }
        if(cur->left) {
            sum += cur->left->val;
            if(traversal(cur->left, count)) return true;
            sum -= cur->left->val;
        }
        if(cur->right) {
            sum += cur->right->val;
            if(traversal(cur->right, count)) return true;
            sum -= cur->right->val;
        }
        return false;
    }
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root == NULL) return false;
        //int sum = root->val;
        return traversal(root, targetSum - root->val);
    }
};
```
`用栈迭代回溯`
- 此时栈里一个元素不仅要记录该节点指针，还要记录从头结点到该节点的路径数值总和。c++就我们用pair结构来存放这个栈里的元素。
```cpp
class Solution {

public:
    bool hasPathSum(TreeNode* root, int sum) {
        if (root == NULL) return false;
        // 此时栈里要放的是pair<节点指针，路径数值>
        stack<pair<TreeNode*, int>> st;
        st.push(pair<TreeNode*, int>(root, root->val));
        while (!st.empty()) {
            pair<TreeNode*, int> node = st.top();
            st.pop();
            // 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true
            if (!node.first->left && !node.first->right && sum == node.second) return true;

            // 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if (node.first->right) {
                st.push(pair<TreeNode*, int>(node.first->right, node.second + node.first->right->val));
            }

            // 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if (node.first->left) {
                st.push(pair<TreeNode*, int>(node.first->left, node.second + node.first->left->val));
            }
        }
        return false;
    }
};
```

## 106.从中序与后序遍历序列构造二叉树
- 构造树一般采用的是前序遍历，因为先构造中间节点，然后递归构造左子树和右子树
```
第一步：如果数组大小为零的话，说明是空节点了。

第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。

第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点

第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）

第五步：切割后序数组，切成后序左数组和后序右数组

第六步：递归处理左区间和右区间
```
```cpp
class Solution {
public:
    TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {
        //第一步
        if(postorder.size() == 0) return NULL;

        //第二步,后序遍历数组最后一个元素，就是当前的中间节点
        int rootValue = postorder[postorder.size() - 1];
        TreeNode *root = new TreeNode(rootValue);

        //叶子节点
        if(postorder.size() == 1) return root;

        // 第三步，找切割点
        int delimiterIndex;
        for(delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {
            if(inorder[delimiterIndex] == rootValue) break;
        }

        // 第四步：切割中序数组，得到中序左数组和中序右数组
        // 左闭右开区间：[0, delimiterIndex)
        vector<int> leftInorder(inorder.begin(), inorder.begin () + delimiterIndex);
        // [delimiterIndex + 1, end)
        vector<int> rightInoder(inorder.begin() + delimiterIndex + 1, inorder.end());

        /*
        - 第五步：切割后序数组，得到后序左数组和后序右数组
        - 首先后序数组的最后一个元素指定不能要了，这是切割点 也是 当前二叉树中间节点的元素，已经用了
        - 中序数组大小一定是和后序数组的大小相同的（这是必然）
        - 中序数组我们都切成了左中序数组和右中序数组了，那么后序数组就可以按照左中序数组的大小来切割，切成左后序数组和右后序数组
        - postorder 舍弃末尾元素，因为这个元素就是中间节点，已经用过了
        */
        postorder.resize(postorder.size() - 1);
        // 左闭右开，注意这里使用了左中序数组大小作为切割点：[0, leftInorder.size)
        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());
        // [leftInorder.size(), end)
        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());

        //第六步，递归调用，顺便从数组构造二叉树
        root->left = traversal(leftInorder, leftPostorder);
        root->right = traversal(rightInoder,rightPostorder);

        return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if (inorder.size() == 0 || postorder.size() == 0) return NULL;
        return traversal(inorder, postorder);
    }
};
```
- 如上的代码性能并不好，因为每层递归定义了新的vector（就是数组），既耗时又耗空间
- 下面给出用下标索引写出的代码版本
```cpp
class Solution {
public:
    TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& postorder, int postorderBegin, int postorderEnd) {
        // 第一步：递归的截止条件
        if(postorderBegin == postorderEnd) return NULL;
        //第二步,后序遍历数组最后一个元素，就是当前的中间节点
        int rootValue = postorder[postorderEnd - 1];
        TreeNode *root = new TreeNode(rootValue);

        //叶子节点,就不用执行下面的逻辑了， 要返回节点的，因为这是构造树
        if(postorderEnd - postorderBegin == 1) return root;

        //获取分割点
        int delimiterIndex;
        for(delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++) {
            if(inorder[delimiterIndex] == rootValue) break;
        }

        // 第四步：切割中序数组
        //左中序区间，左闭右开[leftInorderBegin, leftInorderEnd)
        int leftInorderBegin = inorderBegin;
        int leftInorderEnd = delimiterIndex;
        // 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd)
        int rightInorderBegin = delimiterIndex + 1;
        int rightInorderEnd = inorderEnd;
 
        // 第五步：切割后序数组
        // 左后序区间，左闭右开[leftPostorderBegin, leftPostorderEnd)
        int leftPostorderBegin =  postorderBegin;
        int leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin; // 终止位置是 需要加上 中序区间的大小size
        // 右后序区间，左闭右开[rightPostorderBegin, rightPostorderEnd)
        int rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);
        int rightPostorderEnd = postorderEnd - 1; // 排除最后一个元素，已经作为节点了

        //第六步
        root->left = traversal(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);
        root->right = traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);

        return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if (inorder.size() == 0 || postorder.size() == 0) return NULL;
        // 左闭右开的原则
        return traversal(inorder, 0, inorder.size(), postorder, 0, postorder.size());
    }
};
```

## 654.最大二叉树
- 最大二叉树定义
> - 二叉树的根是数组中的最大元素。
> - 左子树是通过数组中最大值左边部分构造出的最大二叉树。
> - 右子树是通过数组中最大值右边部分构造出的最大二叉树
- 构造树一般采用的是前序遍历，因为先构造中间节点，然后递归构造左子树和右子树
- 终止条件： 当递归遍历的时候，如果传入的数组大小为1，说明遍历到了叶子节点了。
```cpp
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        //首选声明一个操作节点
        TreeNode *node = new TreeNode(0);
        //截止条件
        if(nums.size() == 1){
            node->val = nums[0];
            return node;//递归法这里一定要返回
        }

        // 工具逻辑：找到数组中最大的值和对应的下标
        int maxValue = 0;
        int maxValueIndex = 0;
        for(int i = 0; i < nums.size(); i++) {
            if(nums[i] > maxValue) {
                maxValue = nums[i];
                maxValueIndex = i;
            }
        }
        // 构造树一般这里都会把获取到的值赋值给操作节点
        node->val = maxValue;

        // 左
        if(maxValueIndex > 0) {
            vector<int> newVec(nums.begin(), nums.begin() + maxValueIndex);
            node->left = constructMaximumBinaryTree(newVec);
        }

        // 右
        if (maxValueIndex < (nums.size() - 1)) {
            vector<int> newVec(nums.begin() + maxValueIndex + 1, nums.end());
            node->right = constructMaximumBinaryTree(newVec);
        }

        return node;
    }
};
```
- 效率也不高，每次还要切割的时候每次都要定义新的vector（也就是数组）
- 通过下标索引直接在原数组上操作,需要传入两个int类型：left,right
```cpp
class Solution {
private:
    // 在左闭右开区间[left, right)，构造二叉树
    TreeNode* traversal(vector<int>& nums, int left, int right) {
        if (left >= right) return nullptr;

        // 分割点下标：maxValueIndex
        int maxValueIndex = left;
        for (int i = left + 1; i < right; ++i) {
            if (nums[i] > nums[maxValueIndex]) maxValueIndex = i;
        }

        TreeNode* root = new TreeNode(nums[maxValueIndex]);

        // 左闭右开：[left, maxValueIndex)
        root->left = traversal(nums, left, maxValueIndex);

        // 左闭右开：[maxValueIndex + 1, right)
        root->right = traversal(nums, maxValueIndex + 1, right);

        return root;
    }
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return traversal(nums, 0, nums.size());
    }
};
```