## 236. 二叉树的最近公共祖先
- 遇到这个题目首先想的是要是能自底向上查找就好了，这样就可以找到公共祖先了。那么二叉树如何可以自底向上查找呢？回溯啊，二叉树回溯的过程就是从底到上。后序遍历（左右中）就是天然的回溯过程，可以根据左右子树的返回值，来处理中节点的逻辑。
- 情况一：首先最容易想到的一个情况：如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先
- 情况二：节点本身p(q)，它拥有一个子孙节点q(p)。但是情况一其实就包括了情况二了
- 如果left 和 right都不为空，说明此时root就是最近公共节点。这个比较好理解
- 如果left为空，right不为空，就返回right，说明目标节点是通过right返回的，反之依然。
- [看图解释](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.md)
```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        //截止条件，1.树为空，返回空(y要么一开是就是个空树，要么遍历完了也没找到) 2.找到p,返回p，然后结束3.找到q,返回q,然后结束
        if(root == q || root == p || root == NULL) return root;
        //先用left和right接住左子树和右子树的返回值，根据截止条件，无非返回NULL, q, p
        TreeNode *left = lowestCommonAncestor(root->left, p, q);//左
        TreeNode *right = lowestCommonAncestor(root->right, p, q);//右
        //中
        if(left != NULL && right != NULL) return root;      
        else if(left != NULL && right == NULL) return left;
        else if(left == NULL && right != NULL) return right; 
        //else if(left == NULL && right == NULL) return NULL;
        //return NULL;
        return NULL;
    }
};
```

## 235.二叉搜索树的最近公共祖先
- 要利用二叉树是有序的这一 特性，因为是有序树，所以 如果 中间节点是 q 和 p 的公共祖先，那么 中节点的数组 一定是在 [p, q]区间的。即 中节点 > p && 中节点 < q 或者 中节点 > q && 中节点 < p。那么只要从上到下去遍历，遇到 cur节点是数值在[p, q]区间中则一定可以说明该节点cur就是p 和 q的公共祖先。 那问题来了，一定是最近公共祖先吗？当我们从上向下去递归遍历，第一次遇到 cur节点是数值在[q, p]区间中，那么cur就是 q和p的最近公共祖先
```cpp
class Solution {
private:
    TreeNode *traversal(TreeNode *cur, TreeNode *p, TreeNode *q) {
        if(cur == NULL) return NULL;
        if(cur->val > p->val && cur->val > q->val) {
            //从子树中获取满足条件的值
            TreeNode *left = traversal(cur->left, p, q);
            if(left != NULL) {
                return left;
            }
        }
        if(cur->val < p->val && cur->val < q->val) {
            TreeNode* right = traversal(cur->right, p, q);
            if (right != NULL) {
                return right;
            }
        }
        //介于两者之间满足条件
        return cur;
    }
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return traversal(root, p, q);
    }
};
``` 
`迭代法`
```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        while(root) {
            if (root->val > p->val && root->val > q->val) {
                root = root->left;
            } else if (root->val < p->val && root->val < q->val) {
                root = root->right;
            } else return root;
        }
        return NULL;
    }
};
```