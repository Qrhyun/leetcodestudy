## 404.左叶子之和

- 节点 A 的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么 A 节点的左孩子为左叶子节点

```cpp
class Solution {
public:
    //这里采用后序遍历，先统计左子树，再统计右子树，最后汇聚
    int sumOfLeftLeaves(TreeNode* root) {
        if (root == NULL) return 0;//先讨论第一种特殊情况
        if (root->left == NULL && root->right== NULL) return 0; //再讨论第二种特殊情况

        int leftsum = sumOfLeftLeaves(root->left); // 左子树
        if(root->left && !root->left->left && !root->left->right) {
            // 具体的业务处理：左子树就是一个左叶子的情况
            leftsum = root->left->val;
        }
        int rightsum = sumOfLeftLeaves(root->right); // 右子树

        int sum = leftsum + rightsum; // 中，像这里就不用讨论加上中间的节点了。因为第二种特殊情况已经讨论了
        return sum;
    }
};
```

```cpp
class Solution {
public:
    //这里采用后序遍历，先统计左子树，再统计右子树，最后汇聚
    int sumOfLeftLeaves(TreeNode* root) {
       stack<TreeNode *> a;
       if(root == NULL) return 0;
       if (root->left == NULL && root->right== NULL) return 0;
       int sum = 0;
       a.push(root);
       while(!a.empty()){
         TreeNode *temp = a.top();
         a.pop();
         //中。迭代的终止条件
         if(temp->left != NULL && temp->left->left == NULL && temp->left->right == NULL){
            sum  += temp->left->val;
         }
         //左 。压栈
         if(temp->left) {
            a.push(temp->left);
         }
         //右。 压栈
         if(temp->right) {
            a.push(temp->right);
         }
       }
       return sum;
    }
};
```

## 513.找树左下角的

- 首先要是最后一行，然后是最左边的值
- 利用 a 的不断赋值，就能得到最后的值
- 注意为什么要用层序遍历，因为本题刻意强调最后一行，行的概念就用层序遍历，用队列

```cpp
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
       queue<TreeNode *> que;
       int r = 0;
       que.push(root);
       while(!que.empty()) {
        int size = que.size();
        r = que.front()->val;
        for(int i = 0; i < size; i++) {
            TreeNode *node = que.front();
            que.pop();
            if (node->left) que.push(node->left);
            if (node->right) que.push(node->right);
        }
       }
       return r;
    }
};
```
