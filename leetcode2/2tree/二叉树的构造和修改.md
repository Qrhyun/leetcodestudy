## 106.从中序与后序遍历序列构造二叉树
- 构造树一般采用的是前序遍历，因为先构造中间节点，然后递归构造左子树和右子树
```
第一步：如果数组大小为零的话，说明是空节点了。

第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。

第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点

第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）

第五步：切割后序数组，切成后序左数组和后序右数组

第六步：递归处理左区间和右区间
```
```cpp
class Solution {
public:
    TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {
        //第一步
        if(postorder.size() == 0) return NULL;

        //第二步,后序遍历数组最后一个元素，就是当前的中间节点
        int rootValue = postorder[postorder.size() - 1];
        TreeNode *root = new TreeNode(rootValue);

        //叶子节点
        if(postorder.size() == 1) return root;

        // 第三步，找切割点
        int delimiterIndex;
        for(delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {
            if(inorder[delimiterIndex] == rootValue) break;
        }

        // 第四步：切割中序数组，得到中序左数组和中序右数组
        // 左闭右开区间：[0, delimiterIndex)
        vector<int> leftInorder(inorder.begin(), inorder.begin () + delimiterIndex);
        // [delimiterIndex + 1, end)
        vector<int> rightInoder(inorder.begin() + delimiterIndex + 1, inorder.end());

        /*
        - 第五步：切割后序数组，得到后序左数组和后序右数组
        - 首先后序数组的最后一个元素指定不能要了，这是切割点 也是 当前二叉树中间节点的元素，已经用了
        - 中序数组大小一定是和后序数组的大小相同的（这是必然）
        - 中序数组我们都切成了左中序数组和右中序数组了，那么后序数组就可以按照左中序数组的大小来切割，切成左后序数组和右后序数组
        - postorder 舍弃末尾元素，因为这个元素就是中间节点，已经用过了
        */
        postorder.resize(postorder.size() - 1);
        // 左闭右开，注意这里使用了左中序数组大小作为切割点：[0, leftInorder.size)
        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());
        // [leftInorder.size(), end)
        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());

        //第六步，递归调用，顺便从数组构造二叉树
        root->left = traversal(leftInorder, leftPostorder);
        root->right = traversal(rightInoder,rightPostorder);

        return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if (inorder.size() == 0 || postorder.size() == 0) return NULL;
        return traversal(inorder, postorder);
    }
};
```
- 如上的代码性能并不好，因为每层递归定义了新的vector（就是数组），既耗时又耗空间
- 下面给出用下标索引写出的代码版本
```cpp
class Solution {
public:
    TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& postorder, int postorderBegin, int postorderEnd) {
        // 第一步：递归的截止条件
        if(postorderBegin == postorderEnd) return NULL;
        //第二步,后序遍历数组最后一个元素，就是当前的中间节点
        int rootValue = postorder[postorderEnd - 1];
        TreeNode *root = new TreeNode(rootValue);

        //叶子节点,就不用执行下面的逻辑了， 要返回节点的，因为这是构造树
        if(postorderEnd - postorderBegin == 1) return root;

        //获取分割点
        int delimiterIndex;
        for(delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++) {
            if(inorder[delimiterIndex] == rootValue) break;
        }

        // 第四步：切割中序数组
        //左中序区间，左闭右开[leftInorderBegin, leftInorderEnd)
        int leftInorderBegin = inorderBegin;
        int leftInorderEnd = delimiterIndex;
        // 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd)
        int rightInorderBegin = delimiterIndex + 1;
        int rightInorderEnd = inorderEnd;
 
        // 第五步：切割后序数组
        // 左后序区间，左闭右开[leftPostorderBegin, leftPostorderEnd)
        int leftPostorderBegin =  postorderBegin;
        int leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin; // 终止位置是 需要加上 中序区间的大小size
        // 右后序区间，左闭右开[rightPostorderBegin, rightPostorderEnd)
        int rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);
        int rightPostorderEnd = postorderEnd - 1; // 排除最后一个元素，已经作为节点了

        //第六步
        root->left = traversal(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);
        root->right = traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);

        return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if (inorder.size() == 0 || postorder.size() == 0) return NULL;
        // 左闭右开的原则
        return traversal(inorder, 0, inorder.size(), postorder, 0, postorder.size());
    }
};
```

## 654.最大二叉树
- 最大二叉树定义
> - 二叉树的根是数组中的最大元素。
> - 左子树是通过数组中最大值左边部分构造出的最大二叉树。
> - 右子树是通过数组中最大值右边部分构造出的最大二叉树
- 构造树一般采用的是前序遍历，因为先构造中间节点，然后递归构造左子树和右子树
- 终止条件： 当递归遍历的时候，如果传入的数组大小为1，说明遍历到了叶子节点了。
```cpp
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        //首选声明一个操作节点
        TreeNode *node = new TreeNode(0);
        //截止条件
        if(nums.size() == 1){
            node->val = nums[0];
            return node;//递归法这里一定要返回
        }

        // 中，业务处理核心处
        // 工具逻辑：找到数组中最大的值和对应的下标
        int maxValue = 0;
        int maxValueIndex = 0;
        for(int i = 0; i < nums.size(); i++) {
            if(nums[i] > maxValue) {
                maxValue = nums[i];
                maxValueIndex = i;
            }
        }
        // 构造树一般这里都会把获取到的值赋值给操作节点
        node->val = maxValue;

        // 左递归
        if(maxValueIndex > 0) {
            vector<int> newVec(nums.begin(), nums.begin() + maxValueIndex);
            node->left = constructMaximumBinaryTree(newVec);
        }

        // 右递归
        if (maxValueIndex < (nums.size() - 1)) {
            vector<int> newVec(nums.begin() + maxValueIndex + 1, nums.end());
            node->right = constructMaximumBinaryTree(newVec);
        }

        return node;
    }
};
```
- 效率也不高，每次还要切割的时候每次都要定义新的vector（也就是数组）
- 通过下标索引直接在原数组上操作,需要传入两个int类型：left,right
```cpp
class Solution {
private:
    // 在左闭右开区间[left, right)，构造二叉树
    TreeNode* traversal(vector<int>& nums, int left, int right) {
        if (left >= right) return nullptr;

        // 分割点下标：maxValueIndex
        int maxValueIndex = left;
        for (int i = left + 1; i < right; ++i) {
            if (nums[i] > nums[maxValueIndex]) maxValueIndex = i;
        }

        TreeNode* root = new TreeNode(nums[maxValueIndex]);

        // 左闭右开：[left, maxValueIndex)
        root->left = traversal(nums, left, maxValueIndex);

        // 左闭右开：[maxValueIndex + 1, right)
        root->right = traversal(nums, maxValueIndex + 1, right);

        return root;
    }
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return traversal(nums, 0, nums.size());
    }
};
```

## 617.合并二叉树
`递归法`
- 和遍历一个树逻辑是一样的，只不过传入两个树的节点，同时操作
```cpp
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        //截止条件
        if(root1 == NULL) return root2;
        if(root2 == NULL) return root1;

        root1->val += root2->val;  //中
        root1->left = mergeTrees(root1->left, root2->left);   //左
        root1->right = mergeTrees(root1->right, root2->right);   // 右
        return root1;
    }
};
```
`迭代法`
- 求二叉树对称的时候就是把两个树的节点同时加入队列进行比较。
- 本题我们也使用队列，模拟的层序遍历
```cpp
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == NULL) return t2;
        if (t2 == NULL) return t1;
        queue<TreeNode*> que;
        que.push(t1);
        que.push(t2);
        while(!que.empty()) {
            TreeNode* node1 = que.front(); que.pop();
            TreeNode* node2 = que.front(); que.pop();
            // 此时两个节点一定不为空，val相加
            node1->val += node2->val;

            // 如果两棵树左节点都不为空，加入队列
            if (node1->left != NULL && node2->left != NULL) {
                que.push(node1->left);
                que.push(node2->left);
            }
            // 如果两棵树右节点都不为空，加入队列
            if (node1->right != NULL && node2->right != NULL) {
                que.push(node1->right);
                que.push(node2->right);
            }

            // 当t1的左节点 为空 t2左节点不为空，就赋值过去
            if (node1->left == NULL && node2->left != NULL) {
                node1->left = node2->left;
            }
            // 当t1的右节点 为空 t2右节点不为空，就赋值过去
            if (node1->right == NULL && node2->right != NULL) {
                node1->right = node2->right;
            }
        }
        return t1;
    }
};
```