## 376.摆动序列
- 局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点
- 实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）
- 普遍情况；在计算是否有峰值的时候，大家知道遍历的下标 i ，计算 prediff（nums[i] - nums[i-1]） 和 curdiff（nums[i+1] - nums[i]），如果prediff < 0 && curdiff > 0 或者 prediff > 0 && curdiff < 0 此时就有波动就需要统计。
- 本题要考虑三种特殊情况
#### 平坡分两种，一个是 上下中间有平坡，一个是单调有平坡
> 情况一：上下坡中有平坡
> - 我们记录峰值的条件应该是： `(preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)`
>
> 情况二：数组首尾两端
> - 题目中说了，如果只有两个不同的元素，那摆动序列也是 2。因为我们在计算 `prediff（nums[i] - nums[i-1]）` 和 `curdiff（nums[i+1] - nums[i]）`的时候，至少需要三个数字才能计算，而数组只有两个数字，那么为了规则统一，针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即 `preDiff = 0`
>
>
> 情况三：单调坡中有平坡
> - 例如[1,2,2,2,3,4].我们只需要在 这个坡度摆动变化的时候，更新 prediff 就行，这样 prediff 在 单调区间有平坡的时候 就不会发生变化，造成我们的误判。
```cpp
#include <iostream>
#include <vector>
using namespace std;
class Solution {
public:
 int wiggleMaxLength(vector<int> &nums){
  //1.贪心算法第一点：针对单调坡度，选择坡度的最高和最低，最高，试图尽最大努力保证后面   prediff < 0 && curdiff > 0 或者 prediff > 0 && curdiff < 0
  //2.贪心算法第二点：特殊情况：
      // - 上下坡中有平坡：选择平坡的最右面元素  (preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)
      // - 数组只有两个元素：针对序列[2,5]，可以假设为[2,2,5]，默认最右面有个峰值为1个，还有中间的2满足preDiff = 0 && curDiff > 0
    if(nums.size()<=1) return nums.size(); //如果数组长度小于等于1，直接返回数组长度
    int curDiff=0; //当前差值
    int preDiff=0; //前一个差值
    int result=1; //记录峰值个数，序列默认序列最右边有一个峰值
    for(int i=0;i<nums.size()-1;i++){
      //i从0开始，正是考虑到第二种情况
      //遍历数组，计算当前差值和前一个差值
      curDiff=nums[i+1]-nums[i];
      //preDiff=nums[i]-nums[i-1];//这里可以省去一些计算量，将前面的结果保留到后面
      //如果当前差值和前一个差值一正一负，或者当前差值为0，并且前一个差值为0，说明找到了一个峰值
      if((curDiff>0&&preDiff<=0)||(curDiff<0&&preDiff>=0)){
        result++; //峰值个数加1
        preDiff=curDiff; //只在摆动变化的时候更新preDiff
      }
    }
     //preDiff=curDiff; //更新前一个差值
     return result;
 }
};

//但是正因为情况2导致单调坡中的平坡也算了一次峰值。 单调中的平坡 不能算峰值（即摆动
```
## 738.单调递增的数字
- 例如：98，一旦出现strNum[i - 1] > strNum[i]的情况（非单调递增），首先想让strNum[i - 1]--，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。
- 数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -> 329 -> 299
```cpp
class Solution {
public:
    int monotoneIncreasingDigits(int N) {
        string strNum = to_string(N);
        // flag用来标记赋值9从哪里开始
        // 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行
        int flag = strNum.size();
        for (int i = strNum.size() - 1; i > 0; i--) {
            if (strNum[i - 1] > strNum[i] ) {
                flag = i;
                strNum[i - 1]--;
            }
        }
        for (int i = flag; i < strNum.size(); i++) {
            strNum[i] = '9';
        }
        return stoi(strNum);
    }
};
```