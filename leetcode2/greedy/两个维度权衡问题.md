## 135.分发糖果
- 这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，如果两边一起考虑一定会顾此失彼。
- 此时局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果
```cpp
class Solution {
public:
    int candy(vector<int>& ratings){
      int result=0;
      vector<int> candyNum(ratings.size(),1);//初始化每个孩子的糖果数为1
      //从左往右遍历，保证右边的孩子比左边的孩子的糖果数多，如果右边的孩子比左边的孩子的评分高，那么右边的孩子的糖果数就比左边的孩子的糖果数多1
      for(int i=1;i<ratings.size();i++){
        //这里是从1开始的，因为比较的是i和i-1，所以i不能为0
        if(ratings[i]>ratings[i-1]){
          candyNum[i]=candyNum[i-1]+1;
        }
      }
      result+=candyNum[ratings.size()-1];
      //从右往左遍历，保证左边的孩子比右边的孩子的糖果数多，如果左边的孩子比右边的孩子的评分高，那么左边的孩子的糖果数就比右边的孩子的糖果数多1
      for(int i=ratings.size()-2;i>=0;i--){
        //这里是从ratings.size()-2开始的，因为比较的是i和i+1，所以i不能为ratings.size()-1
        if(ratings[i]>ratings[i+1]){
          candyNum[i]=max(candyNum[i],candyNum[i+1]+1);
        }
        result+=candyNum[i];
      }
      return result;
    }
};
```
## 406.根据身高重建队列
- 本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后再按照另一个维度重新排列。
- 按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！
- 局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性
```cpp
class Solution {
public:
    static bool cmp (const vector<int> &a, const vector<int> &b) {
        
        if(a[0] == b[0]) return a[1] < b[1];//如果身高相同，那么最好0排在1前面，可以提高效率
        return a[0] > b[0];//如果身高不相同，身高高的排在前面
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(), cmp);
        vector<vector<int>> que;
        for(int i = 0; i < people.size(); i++) {
            int position = people[i][1];//第二个值
            que.insert(que.begin() + position, people[i]);//第一个参数是位置，第二个参数是插入的值
        }
        return que;
    }
};
```
- 使用vector（动态数组）来insert，是费时的，插入再拷贝的话，单纯一个插入的操作就是O(n^2)了，甚至可能拷贝好几次，就不止O(n^2)了。----改成链表
```cpp
// 版本二
class Solution {
public:
    // 身高从大到小排（身高相同k小的站前面）
    static bool cmp(const vector<int>& a, const vector<int>& b) {
        if (a[0] == b[0]) return a[1] < b[1];
        return a[0] > b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort (people.begin(), people.end(), cmp);
        list<vector<int>> que; // list底层是链表实现，插入效率比vector高的多
        for (int i = 0; i < people.size(); i++) {
            int position = people[i][1]; // 插入到下标为position的位置
            std::list<vector<int>>::iterator it = que.begin();
            while (position--) { // 寻找在插入位置
                it++;
            }
            que.insert(it, people[i]);
        }
        return vector<vector<int>>(que.begin(), que.end());
    }
};
```