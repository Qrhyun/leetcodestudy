## 55. 跳跃游戏
- 问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！
- 每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围
- 贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。
- i 每次移动只能在 cover 的范围内移动，每移动一个元素，cover 得到该元素数值（新的覆盖范围）的补充，让 i 继续移动下去。而 cover 每次只取 max(该元素数值补充后的范围, cover 本身范围)。
`错误的写法`
```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int cover = 0;
        if(nums.size() == 1) return true;
        for(int i = 0; i < nums.size(); i++) {
           cover += nums[i];
           if(cover >= nums.size()) {
            return true;
           }
        }
    return false;
    }
};
```
`正确的写法`
- 感觉这里面有着回溯的影子
```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int cover = 0;
        if(nums.size() == 1) return true;
        for(int i = 0; i <= cover; i++){
            cover = max(i + nums[i], cover);
            if(cover >= nums.size() - 1) return true;
        }
    return false;
    }
};
```
## 45.跳跃游戏 II
- 这道题目和上一题的区别在于需要返回最小跳跃次数。
- 贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最少步数。思路虽然是这样，但在写代码的时候还不能真的能跳多远就跳多远，那样就不知道下一步最远能跳到哪里了。
- 所以真正解题的时候，要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最少步数！这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖。
```cpp
// 版本一
class Solution {
public:
    int jump(vector<int>& nums) {
        if (nums.size() == 1)
            return 0;
        int ans = 0;          // 记录走的最大步数
        int curDistance = 0;  // 当前覆盖最远距离下标
        int nextDistance = 0; // 下一步覆盖最远距离下标
        for (int i = 0; i < nums.size(); i++) {
            nextDistance = max(nums[i] + i, nextDistance); // 更新下一步覆盖最远距离下标
            if (i == curDistance) {
                if (curDistance != nums.size() - 1) {
                    ans++;
                    curDistance = nextDistance;
                    if (nextDistance >= nums.size() - 1)
                        break;
                } else {
                    break;
                }
            }
        }
        return ans;
    }
};
```
- 针对于方法一的特殊情况，可以统一处理，即：移动下标只要遇到当前覆盖最远距离的下标，直接步数加一，不考虑是不是终点的情况。
- 想要达到这样的效果，只要让移动下标，最大只能移动到 nums.size - 2 的地方就可以了
```cpp
// 版本二
class Solution {
public:
    int jump(vector<int>& nums) {
        int curDistance = 0;    // 当前覆盖的最远距离下标
        int ans = 0;            // 记录走的最大步数
        int nextDistance = 0;   // 下一步覆盖的最远距离下标
        for (int i = 0; i < nums.size() - 1; i++) { // 注意这里是小于nums.size() - 1，这是关键所在
            nextDistance = max(nums[i] + i, nextDistance); // 更新下一步覆盖的最远距离下标
            if (i == curDistance) {                 // 遇到当前覆盖的最远距离下标
                curDistance = nextDistance;         // 更新当前覆盖的最远距离下标
                ans++;
            }
        }
        return ans;
    }
};
```
## 763.划分字母区间
- 在遍历的过程中相当于是要找每一个字母的边界，如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了。此时前面出现过所有字母，最远也就到这个边界了
- 可以分为如下两步：

  + 统计每一个字符最后出现的位置
  + 从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点

```cpp
class Solution {
public:
    vector<int> partitionLabels(string s) {
        int hash[27] = {0};// i为字符，hash[i]为字符出现的最后位置
        for(int i = 0; i < s.size(); i++) {// 统计每一个字符最后出现的位置
            hash[s[i] - 'a'] = i;
        }
        vector<int> result;
        int left = 0;
        int right = 0;
        for(int i = 0; i < s.size(); i++) {
            right = max(right, hash[s[i] - 'a']);// 找到字符出现的最远边界
            if(i == right){
                result.push_back(right - left + 1);
                left = i+1;
            }
        }
        return result;
    }
};
```
