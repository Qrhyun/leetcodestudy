# 观看顺序
300 - 674 - 718 - 1143 - 1035 - 53
# 一.子序列不连续
## 300.最长上升子序列
- 不强调连续
- dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度
- 递归公式
   > dp[i] = max(dp[i], dp[j] + 1);
- 初始化：dp[i] = 1,最少都是1
- 遍历顺序：依赖于当前nums[i]和前面的进行比较，所以是从小到大遍历
- 注意本题最后返回的不是`dp[nums.size() - 1]`，而是result，因为假设一种情况，最后一个元素不在递增子序列里面，那么`dp[nums.size() - 1]`就会不走`dp[i] = max(dp[i], dp[j] + 1);`, 而是取默认值1
```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();//特殊情况，只有0个或者1个元素
        vector<int> dp(nums.size(), 1);
        int result = 0;
        for (int i = 1; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {//遍历0-i之间的所有值，来比较nums[i]和nums[j]
                if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
            }
            if (dp[i] > result) result = dp[i]; // 取长的子序列
        }
        return result;
    }
};
```
## 1143.最长公共子序列
- 要求是不连续的
- dp[i][j]：长度为`[0, i - 1]`的字符串text1与长度为`[0, j - 1]`的字符串text2的最长公共子序列为dp[i][j]
- 递归公式这里因为不连续所以和718不一样
- 这里的返回值存放的地方也不一样
```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
        for (int i = 1; i <= text1.size(); i++) {
            for (int j = 1; j <= text2.size(); j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[text1.size()][text2.size()];
    }
};
```
## 1035.不相交的线
- 其实是找相同子序列，其实和上题差不多一样，最长公共子序列
```cpp
class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        vector<vector<int>> dp(nums1.size() + 1, vector<int>(nums2.size() + 1, 0));
        for (int i = 1; i <= nums1.size(); i++) {
            for (int j = 1; j <= nums2.size(); j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[nums1.size()][nums2.size()];
    }
};
```


# 二.子序列连续
## 674. 最长连续递增序列
- 强调连续
- dp[i]：以下标i为结尾的连续递增的子序列长度为dp[i]。
- 递归公式
   > dp[i] = max(dp[i], dp[j] + 1);
- 初始化：dp[i] = 1,最少都是1
- 遍历顺序：依赖于当前nums[i]和前面的进行比较，所以是从小到大遍历,这里只需要比较nums[i]和nums[i-1]就可以了，因为是连续的，这是唯一的区别
- 注意本题最后返回的不是`dp[nums.size() - 1]`，而是result，因为假设一种情况，最后一个元素不在递增子序列里面，那么`dp[nums.size() - 1]`就会不走`dp[i] = max(dp[i], dp[j] + 1);`, 而是取默认值1
```cpp
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        int result = 1;
        vector<int> dp(nums.size() ,1);
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > nums[i - 1]) { // 连续记录
                dp[i] = dp[i - 1] + 1;
            }
            if (dp[i] > result) result = dp[i];
        }
        return result;
    }
};
```
## 718. 最长重复子数组
- 两个数组的重复子序列，实际上也在强调连续
- dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]（特别注意： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）
- 递归公式：当`A[i - 1]` 和`B[j - 1]`相等的时候，`dp[i][j] = dp[i - 1][j - 1] + 1;`
- 初始化：但dp[i][0] 和dp[0][j]要初始值，因为 为了方便递归公式dp[i][j] = dp[i - 1][j - 1] + 1;所以dp[i][0] 和dp[0][j]初始化为0。举个例子A[0]如果和B[0]相同的话，dp[1][1] = dp[0][0] + 1，只有dp[0][0]初始为0，正好符合递推公式逐步累加起来。
- 遍历顺序：遍历nums1,遍历nums2，需要两个循环
```cpp
// 版本一
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        vector<vector<int>> dp (nums1.size() + 1, vector<int>(nums2.size() + 1, 0));
        int result = 0;
        for (int i = 1; i <= nums1.size(); i++) {
            for (int j = 1; j <= nums2.size(); j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                if (dp[i][j] > result) result = dp[i][j];
            }
        }
        return result;
    }
};
```
## 53.最大子序和
- 给定一个整数数组 nums ，找到一个具有最大和的**连续**子数组（子数组最少包含一个元素），返回其最大和。
- dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]。
- 递归公式
  > - 情况1：延续前面的
  > - 情况2：抛弃前面的，从此刻开始
  > - `dp[i] = max(dp[i - 1] + nums[i], nums[i]);`
- 初始化：dp[0] = 0 
- 遍历顺序：从前往后遍历 
- 这里的结果不是`dp[nums.size() - 1]`，而是result
```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        int result = dp[0];
        for (int i = 1; i < nums.size(); i++) {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]); // 状态转移公式
            if (dp[i] > result) result = dp[i]; // result 保存dp[i]的最大值
        }
        return result;
    }
};
```
# 三. 编辑距离
## 392.判断子序列
- 类似于最长公共子序列
- dp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]。
- 递归公式：if (s[i - 1] == t[j - 1])，那么dp[i][j] = dp[i - 1][j - 1] + 1;，因为找到了一个相同的字符，相同子序列长度自然要在dp[i-1][j-1]的基础上加1（如果不理解，在回看一下dp[i][j]的定义）
- 初始化：dp[i][0]  = 0, dp[0][j] = 0
- 遍历顺序：从前往后遍历 
```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0));
        for(int i = 1; i <= s.size(); i++) {
            for(int j = 1; j <= t.size(); j++) {
                if(s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = dp[i][j - 1];
            }
        }
        if(dp[s.size()][t.size()] == s.size()) return true;
        return false;
    }
};
```
## 115.不同的子序列
