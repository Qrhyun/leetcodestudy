## 198.打家劫舍
- dp[i]：考虑下标i之前（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。
- 递归公式 ：针对dp[i], 分为偷i,不偷i
   > - 偷i: `dp[i] = dp[i - 2] + nums[i]`
   > - 不偷i: `dp[i] = dp[i - 1]`
   > - 所以`dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])`
- 初始化：根据递推公式的最底层，需要初始化dp[0]和dp[1]，dp[0] =nums[0], dp[1] = max(nums[0], nums[1]),其他初始化随便
- 遍历顺序：从小到大，i从2开始
- 注意：一开始的特殊情况要返回，这和初始化dp[0]和dp[1]是两码事
```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        if(nums.size() == 1) return nums[0];
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for(int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[nums.size() - 1];
    }
};
```
## 213.打家劫舍II
- 连成了环，首和尾相连，首和尾要么只选一个，要么全不选
- 所以分为三种情况：
   1. 只偷首不偷尾，直接调用198题的线性dp函数,没啥影响
   2. 只偷尾不偷首，直接调用198题的线性dp函数,没啥影响
   3. 首尾都不偷，直接调用198题的线性dp函数,没啥影响
   4. 其实情况1，2是包含情况3的，所以只需要考虑1，2，情况1，2的最大值就是结果
```cpp
// 注意注释中的情况二情况三，以及把198.打家劫舍的代码抽离出来了
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        if (nums.size() == 1) return nums[0];
        int result1 = robRange(nums, 0, nums.size() - 2); // 情况二
        int result2 = robRange(nums, 1, nums.size() - 1); // 情况三
        return max(result1, result2);
    }
    // 198.打家劫舍的逻辑
    int robRange(vector<int>& nums, int start, int end) {
        if (end == start) return nums[start];
        vector<int> dp(nums.size());
        dp[start] = nums[start];
        dp[start + 1] = max(nums[start], nums[start + 1]);
        for (int i = start + 2; i <= end; i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[end];
    }
};
```

## 337.打家劫舍III
- [不想看了，太恶心，后期todo.......](https://www.bilibili.com/video/BV1H24y1Q7sY/?vd_source=b3fd84988e8e921a37b4fa1da8d481db)
  