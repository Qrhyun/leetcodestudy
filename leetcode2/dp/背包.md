## 01背包问题
> - 有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。
> - 问题是装满这个背包，最大价值是什么
### 二维dp数组01背包
- [b站](https://www.bilibili.com/video/BV1BU4y177kY?vd_source=b3fd84988e8e921a37b4fa1da8d481db&spm_id_from=333.788.videopod.sections)
- 二维数组为 dp[i][j]:i 来表示物品、j表示背包容量。最终表示最大价值
- 递归：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`
- 初始化： 如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0；dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值
- 遍历顺序：有两个遍历的维度：物品与背包重量
- 先给出先遍历物品，然后遍历背包重量的代码：
```cpp
// weight数组的大小 就是物品个数
for(int i = 1; i < weight.size(); i++) { // 遍历物品
    for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

    }
}
```
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, bagweight;// bagweight代表行李箱空间

    cin >> n >> bagweight;

    vector<int> weight(n, 0); // 存储每件物品所占空间
    vector<int> value(n, 0);  // 存储每件物品价值

    for(int i = 0; i < n; ++i) {
        cin >> weight[i];
    }
    for(int j = 0; j < n; ++j) {
        cin >> value[j];
    }
    // dp数组, dp[i][j]代表行李箱空间为j的情况下,从下标为[0, i]的物品里面任意取,能达到的最大价值
    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));

    // 初始化, 因为需要用到dp[i - 1]的值
    // j < weight[0]已在上方被初始化为0
    // j >= weight[0]的值就初始化为value[0]
    for (int j = weight[0]; j <= bagweight; j++) {
        dp[0][j] = value[0];
    }

    for(int i = 1; i < weight.size(); i++) { // 遍历科研物品
        for(int j = 0; j <= bagweight; j++) { // 遍历行李箱容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j]; // 如果装不下这个物品,那么就继承dp[i - 1][j]的值
            else {
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
            }
        }
    }
    cout << dp[n - 1][bagweight] << endl;

    return 0;
}
```
### 一维数组01背包---滚动数组
- [b站](https://www.bilibili.com/video/BV1BU4y177kY?vd_source=b3fd84988e8e921a37b4fa1da8d481db&spm_id_from=333.788.videopod.sections)
- 一维数组为 dp[j]:j表示背包容量。最终表示最大价值
- 递归：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);`
- 初始化： 如果背包容量j为0的话，即dp[0]，无论是选取哪些物品，背包价值总和一定为0；
- 遍历顺序：有两个遍历的维度：物品与背包重量,必须先遍历物品,再遍历背包容量，而且必须是倒序遍历
> ```cpp
> for(int i = 0; i < weight.size(); i++) { // 遍历物品
>    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
>       dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
>
>    }
> } 
> ```
```cpp
// 一维dp数组实现
#include <iostream>
#include <vector>
using namespace std;

int main() {
    // 读取 M 和 N
    int M, N;
    cin >> M >> N;

    vector<int> costs(M);
    vector<int> values(M);

    for (int i = 0; i < M; i++) {
        cin >> costs[i];
    }
    for (int j = 0; j < M; j++) {
        cin >> values[j];
    }

    // 创建一个动态规划数组dp，初始值为0
    vector<int> dp(N + 1, 0);

    // 外层循环遍历每个类型的研究材料
    for (int i = 0; i < M; ++i) {
        // 内层循环从 N 空间逐渐减少到当前研究材料所占空间
        for (int j = N; j >= costs[i]; --j) {
            // 考虑当前研究材料选择和不选择的情况，选择最大值
            dp[j] = max(dp[j], dp[j - costs[i]] + values[i]);
        }
    }

    // 输出dp[N]，即在给定 N 行李空间可以携带的研究材料最大价值
    cout << dp[N] << endl;

    return 0;
}
```
## 416.分割等和子集
- 本题背包的大小（即重量）是可以变化的，背包的最大价值等于其最大重量，物品的重量也是其价值
- 问题是能不能装满这个背包
- 抽象成01背包：当数字可以装满承载重量为 `sum / 2` 的背包的背包时，这个背包的价值也是 `sum / 2`。那么这道题就是装满承载重量为 `sum / 2` 的背包，价值最大是多少？如果最大价值是 `sum / 2`，说明正好被商品装满了。
- dp[j] 表示： 容量（所能装的重量）为j的背包，所背的物品价值最大可以为`dp[j]`。当 `dp[target] == target` 的时候，背包就装满了，这个`target`必须是`sum/2`
- 01背包的递推公式为：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`物品i的重量是`nums[i]`，其价值也是`nums[i]`
```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) { 
        int sum = 0;
        // dp[i]中的i表示背包内总和
        // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200
        // 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了
        vector<int>dp(10001, 0);
        //求总和
        for(int i = 0; i < nums.size(); i++) {
            sum += nums[i];
        }
        // 也可以使用库函数一步求和
        // int sum = accumulate(nums.begin(), nums.end(), 0);
        if(sum % 2 == 1) return false;
        int target = sum / 2;

        //开始01背包
        for(int i = 0; i < nums.size(); i++) {
            for(int j = target; j >= nums[i]; j--) {
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        if(dp[target] == target) return true;
        return false;
    }
};
```
## 1049.最后一块石头的重量I
- 物品就是石头，物品的重量为`stones[i]`，物品的价值也为`stones[i]`
- 问题是给一个背包，尽量往里面装，能装多少装多少
- 本题其实是尽量让石头分成重量相同的两堆（尽可能相同），相撞之后剩下的石头就是最小的。
- 一堆的石头重量是sum，那么我们就尽可能拼成 重量为 `sum / 2` 的石头堆。 这样剩下的石头堆也是 尽可能接近 `sum/2` 的重量。 那么此时问题就是有一堆石头，每个石头都有自己的重量，是否可以装满最大重量为 `sum / 2`的背包。
- dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]
- 递推公式：`dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);`
- 初始化：
> - 首先确定背包的重量的上限，即`vector<int> dp`的大小，为`sum/2`,根据题目的范围来确定
> - 然后初始化`dp[i]`,因为重量都不会是负数，所以dp[j]都初始化为0就可以了
> - 综上：`vector<int> dp(15001, 0);`
- 遍历顺序和上面的题目一样
```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        vector<int> dp(15001, 0);
        int sum = 0 ;
        for(int i = 0; i < stones.size(); i++) {
            sum += stones[i];
        } 
        int target = sum / 2;
        for(int i = 0; i < stones.size(); i++) {
            for(int j = target; j >= stones[i]; j--) {
                dp[j] = max(dp[j], stones[i] + dp[j - stones[i]]);
            }
        }
        return sum - dp[target] - dp[target];
    }
};
```

## 494.目标和
- [b站](https://www.bilibili.com/video/BV1o8411j73x/?vd_source=b3fd84988e8e921a37b4fa1da8d481db)
- 假设加法的总和为`x`，那么减法对应的总和就是`sum - x`。所以我们要求的是 `x - (sum - x) = target`,得出`x = (target + sum) / 2`此时问题就转化为，用nums装满容量为x的背包，有几种方法。这里的x，就是`bagSize`，也就是我们后面要求的背包容量
- 本题是给一个背包，有多少种风湿可以把它装满
- dp[j]，表示：填满j（包括j）这么大容积的包，有dp[j]种方法。
```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (abs(target) > sum) return 0; // 此时没有方案
        if ((target + sum) % 2 == 1) return 0; // 此时没有方案
        int bagSize = (target + sum) / 2;
        vector<int> dp(bagSize + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = bagSize; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[bagSize];
    }
};
```