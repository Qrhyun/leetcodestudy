## 01背包问题
> - 有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。
> - 问题是装满这个背包，最大价值是什么
### 二维dp数组01背包
- [b站](https://www.bilibili.com/video/BV1BU4y177kY?vd_source=b3fd84988e8e921a37b4fa1da8d481db&spm_id_from=333.788.videopod.sections)
- 二维数组为 dp[i][j]:i 来表示物品、j表示背包容量。最终表示最大价值
- 递归：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`
- 初始化： 如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0；dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值
- 遍历顺序：有两个遍历的维度：物品与背包重量
- 先给出先遍历物品，然后遍历背包重量的代码：
```cpp
// weight数组的大小 就是物品个数
for(int i = 1; i < weight.size(); i++) { // 遍历物品
    for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

    }
}
```
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, bagweight;// bagweight代表行李箱空间

    cin >> n >> bagweight;

    vector<int> weight(n, 0); // 存储每件物品所占空间
    vector<int> value(n, 0);  // 存储每件物品价值

    for(int i = 0; i < n; ++i) {
        cin >> weight[i];
    }
    for(int j = 0; j < n; ++j) {
        cin >> value[j];
    }
    // dp数组, dp[i][j]代表行李箱空间为j的情况下,从下标为[0, i]的物品里面任意取,能达到的最大价值
    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));

    // 初始化, 因为需要用到dp[i - 1]的值
    // j < weight[0]已在上方被初始化为0
    // j >= weight[0]的值就初始化为value[0]
    for (int j = weight[0]; j <= bagweight; j++) {
        dp[0][j] = value[0];
    }

    for(int i = 1; i < weight.size(); i++) { // 遍历科研物品
        for(int j = 0; j <= bagweight; j++) { // 遍历行李箱容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j]; // 如果装不下这个物品,那么就继承dp[i - 1][j]的值
            else {
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
            }
        }
    }
    cout << dp[n - 1][bagweight] << endl;

    return 0;
}
```
### 一维数组01背包---滚动数组
- [b站](https://www.bilibili.com/video/BV1BU4y177kY?vd_source=b3fd84988e8e921a37b4fa1da8d481db&spm_id_from=333.788.videopod.sections)
- 一维数组为 dp[j]:j表示背包容量。最终表示最大价值
- 递归：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);`
- 初始化： 如果背包容量j为0的话，即dp[0]，无论是选取哪些物品，背包价值总和一定为0；
- 遍历顺序：有两个遍历的维度：物品与背包重量,必须先遍历物品,再遍历背包容量，而且必须是倒序遍历
> ```cpp
> for(int i = 0; i < weight.size(); i++) { // 遍历物品
>    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
>       dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
>
>    }
> } 
> ```
```cpp
// 一维dp数组实现
#include <iostream>
#include <vector>
using namespace std;

int main() {
    // 读取 M 和 N
    int M, N;
    cin >> M >> N;

    vector<int> costs(M);
    vector<int> values(M);

    for (int i = 0; i < M; i++) {
        cin >> costs[i];
    }
    for (int j = 0; j < M; j++) {
        cin >> values[j];
    }

    // 创建一个动态规划数组dp，初始值为0
    vector<int> dp(N + 1, 0);

    // 外层循环遍历每个类型的研究材料
    for (int i = 0; i < M; ++i) {
        // 内层循环从 N 空间逐渐减少到当前研究材料所占空间
        for (int j = N; j >= costs[i]; --j) {
            // 考虑当前研究材料选择和不选择的情况，选择最大值
            dp[j] = max(dp[j], dp[j - costs[i]] + values[i]);
        }
    }

    // 输出dp[N]，即在给定 N 行李空间可以携带的研究材料最大价值
    cout << dp[N] << endl;

    return 0;
}
```
## 416.分割等和子集
- 本题背包的大小（即重量）是可以变化的，背包的最大价值等于其最大重量，物品的重量也是其价值
- 问题是能不能装满这个背包
- 抽象成01背包：当数字可以装满承载重量为 `sum / 2` 的背包的背包时，这个背包的价值也是 `sum / 2`。那么这道题就是装满承载重量为 `sum / 2` 的背包，价值最大是多少？如果最大价值是 `sum / 2`，说明正好被商品装满了。
- dp[j] 表示： 容量（所能装的重量）为j的背包，所背的物品价值最大可以为`dp[j]`。当 `dp[target] == target` 的时候，背包就装满了，这个`target`必须是`sum/2`
- 01背包的递推公式为：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`物品i的重量是`nums[i]`，其价值也是`nums[i]`
```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) { 
        int sum = 0;
        // dp[i]中的i表示背包内总和
        // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200
        // 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了
        vector<int>dp(10001, 0);
        //求总和
        for(int i = 0; i < nums.size(); i++) {
            sum += nums[i];
        }
        // 也可以使用库函数一步求和
        // int sum = accumulate(nums.begin(), nums.end(), 0);
        if(sum % 2 == 1) return false;
        int target = sum / 2;

        //开始01背包
        for(int i = 0; i < nums.size(); i++) {
            for(int j = target; j >= nums[i]; j--) {
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        if(dp[target] == target) return true;
        return false;
    }
};
```
## 1049.最后一块石头的重量I
- 物品就是石头，物品的重量为`stones[i]`，物品的价值也为`stones[i]`
- 问题是给一个背包，尽量往里面装，能装多少装多少
- 本题其实是尽量让石头分成重量相同的两堆（尽可能相同），相撞之后剩下的石头就是最小的。
- 一堆的石头重量是sum，那么我们就尽可能拼成 重量为 `sum / 2` 的石头堆。 这样剩下的石头堆也是 尽可能接近 `sum/2` 的重量。 那么此时问题就是有一堆石头，每个石头都有自己的重量，是否可以装满最大重量为 `sum / 2`的背包。
- dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]
- 递推公式：`dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);`
- 初始化：
> - 首先确定背包的重量的上限，即`vector<int> dp`的大小，为`sum/2`,根据题目的范围来确定
> - 然后初始化`dp[i]`,因为重量都不会是负数，所以dp[j]都初始化为0就可以了
> - 综上：`vector<int> dp(15001, 0);`
- 遍历顺序和上面的题目一样
```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        vector<int> dp(15001, 0);
        int sum = 0 ;
        for(int i = 0; i < stones.size(); i++) {
            sum += stones[i];
        } 
        int target = sum / 2;
        for(int i = 0; i < stones.size(); i++) {
            for(int j = target; j >= stones[i]; j--) {
                dp[j] = max(dp[j], stones[i] + dp[j - stones[i]]);
            }
        }
        return sum - dp[target] - dp[target];
    }
};
```

## 494.目标和
- [b站](https://www.bilibili.com/video/BV1o8411j73x/?vd_source=b3fd84988e8e921a37b4fa1da8d481db)
- 假设加法的总和为`x`，那么减法对应的总和就是`sum - x`。所以我们要求的是 `x - (sum - x) = target`,得出`x = (target + sum) / 2`此时问题就转化为，用nums装满容量为x的背包，有几种方法。这里的x，就是`bagSize`，也就是我们后面要求的背包容量
- 本题是给一个背包，有多少种方式可以把它装满
- dp[j]，表示：填满j（包括j）这么大容积的包，有dp[j]种方法。
```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (abs(target) > sum) return 0; // 此时没有方案
        if ((target + sum) % 2 == 1) return 0; // 此时没有方案
        int bagSize = (target + sum) / 2;
        vector<int> dp(bagSize + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = bagSize; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[bagSize];
    }
};
```
## 474.一和零
- 上面的背包都是一个维度，而这个背包是两个个维度，要求有两个重量
- 本题的重量是一个二维表示，价值是字符串（商品）的个数，每装一个商品，价值加一
- dp[i][j]：最多有i个0和j个1的strs的**最大子集的大小**为dp[i][j]。
- 递推公式：`dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);`
- 初始化：`dp[0][0] = 0`,非零下标也初始化为0
- 本题实际上也是用的一维01背包方法，只不过是背包有两个维度而已
- 遍历顺序：
```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));// 默认初始化0
        //int x = 0, y = 0;这两句不可以放在这里
        for(string str : strs) {//遍历商品
            int x = 0, y = 0;//为每一个字符串统计01个数
            for(char c : str) {
                if(c == '0') {
                    x++;
                }else{
                    y++;
                }
            }
            //遍历背包
            for(int i = m; i >= x; i--) {
                for(int j = n; j >= y; j--) {
                    dp[i][j] = max(dp[i][j], dp[i - x][j - y] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```
## 完全背包
- 完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。
- 区别就是把一维方法遍历的for循环改成正序遍历
- 01背包里面的一维方法必须是先遍历商品，再遍历背包；但是完全背包里面的一位方法都可以

## 518.零钱兑换II
- 组合数：不强调顺序
- 本题类似于目标和：都是装满这个背包需要多少种方法
- dp[j]：凑成总金额j的货币组合数为dp[j]
- 递推公式：
   > 二维：`dp[i][j] = dp[i - 1][j] +  dp[i][j - coins[i]]`
   > 一维：`dp[j] += dp[j - coins[i]]`  求装满背包有几种方法，公式都是：`dp[j] += dp[j - nums[i]]`
- 初始化：dp[0] = 1(因为本题的话，递推公式不是比较max,而是+=),非零下标默认初始化0就可以了，与max情况相比的话，只有dp[0] = 1
- 遍历顺序：
   > 先放商品，再放背包的话：得出的就是组合数（也就说只有1，2，没有2，1，这样就保证了组合数）。
   > 先放背包，再放商品的话：得出的是排列数（1，2和2，1不是同一种情况）
```cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<uint64_t> dp(amount + 1, 0);// 防止相加数据超int
        dp[0] = 1;
        for(int i = 0; i < coins.size(); i++) {
            for(int j = coins[i]; j <= amount; j++) {
              //记住上面这个循环里面j=coins[i],而不是0，这是为了防止下面 j-coins[i]出现负数的情况
                dp[j] += dp[j - coins[i]];//记住是dp[j],而不是dp[amount]
            }
        }
        return dp[amount];
    }
};
```
```cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1, 0);
        dp[0] = 1; // 只有一种方式达到0
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                if(dp[j] + dp[j - coins[i]] < INT_MAX) {
                    dp[j] += dp[j - coins[i]]; // 组合数
                }
            }
        }
        return dp[amount]; // 返回组合数
    }
};
```
## 377.组合总和Ⅳ 
- 填满背包有多少种方法的问题 
- 排列数   
- 本题一定要加上`if(j - nums[i] >= 0)`
```cpp
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<uint64_t> dp(target + 1, 0);
        dp[0] = 1;
        for(int j = 0; j <= target; j++) {
            for(int i = 0; i < nums.size(); i++) {
                if(j - nums[i] >= 0) {
                dp[j] += dp[j - nums[i]];
                }
            }
        }
        return dp[target];
    }
};
```   
## 322. 零钱兑换
- 这个题目是完全背包问题，全是正序循环。同时本题不涉及组合和排列
- 零钱兑换Ⅱ是问有几种方法，用`+=`;这个题目是问最少需要多少个硬币来凑成总金额，使用`min`。
- 个数就是价值，所以value[i]就是数字1
- dp[j]：凑足总额为j所需钱币的最少个数为dp[j]
- 递推公式：`dp[j] = min(dp[j - coins[i]] + 1, dp[j]);`
- 初始化：前面的`max`类型的初始化基本全是默认初始化为`0`；前面+=类型的初始化基本全是默认初始化为`uint64_t`的（防止加起来的数字过于大，超出范围）全0，然后`dp[0] = 1`。本题`min`类型的初始化应该是`dp[0] = 0`,非零下标初始为`vector<int> dp(amount + 1, INT_MAX);`
```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for(int i = 0; i < coins.size(); i++) {
            for(int j = coins[i]; j <= amount; j++) {
                if( dp[j - coins[i]] != INT_MAX) {
                dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
                }
            } 
        }
        if (dp[amount] == INT_MAX) return -1;
        return dp[amount];
    }
};
```
## 279.完全平方数
- 本题是完全背包问题，全是正序循环。同时本题不涉及组合和排列
- 价值是`i*i`，这是本题与上面那个题目的区别
- 遍历顺序：首先第一个for循环i是从1开始的，因为0的0次方没意义；下一个for循环j从i*i开始，因为最少也是i*i开始，然后题目要求一直求到n;
```cpp
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n+1, INT_MAX);
        dp[0] = 0;
        for(int i = 1; i * i <= n; i++) {
            for(int j = i * i; j <= n; j++) {
                dp[j] = min(dp[j - i * i] + 1, dp[j]);
            }
        }
        return dp[n];
    }
};
```
## 139.单词拆分
- 和回文字符串很像，可以用回溯算法来做
- 单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。拆分时可以重复使用字典中的单词，说明就是一个完全背包！
- dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。之所以选择i为字符串的长度来标记一个背包，是因为要考虑空字符串的情况，空字符串可以用dp[0]来标志
- 递推公式：如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j < i ）所以递推公式是 if([j, i] 这个区间的子串出现在字典里 && dp[j]是true) 那么 dp[i] = true。
- 初始化 dp[0] =true,非零下标的话全部初始成fasle，因为还不确认能否为满足条件的字符串
- 遍历顺序：本题是排列数，对装满字符串要有顺序，先遍历背包，再遍历物品
```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for(int j = 1; j <= s.size(); j++) {
            for(int i = 0; i < j; i++) {
                string word = s.substr(i, j - i); //substr(起始位置，截取的个数)
                if (wordSet.find(word) != wordSet.end() && dp[i]) {
                    dp[j] = true;
                }
            }
        }
         return dp[s.size()];
    }
};
```