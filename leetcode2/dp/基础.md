## 509. 斐波那契数

1. 确定 dp 数组以及下标的含义:dp[i]的定义为：第 i 个数的斐波那契数值是 dp[i]
2. 确定递推公式: dp[i] = dp[i - 1] + dp[i - 2]
3. dp 数组如何初始化: dp[0] = 0;dp[1] = 1;
4. 确定遍历顺序:从递归公式 dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的
5. 举例推导 dp 数组

```cpp
class Solution {
public:
    int fib(int n) {
        if(n<=1) return n;
        vector<int> dp(n+1);//1
        dp[0] = 0;//3
        dp[1] = 1;
        for(int i = 2; i <= n; i++) {//4
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

## 70.爬楼梯

- 第二步，确定递归公式：
  > 从 dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。
  >
  > - 首先是 dp[i - 1]，上 i-1 层楼梯，有 dp[i - 1]种方法，那么再一步跳一个台阶不就是 dp[i]了么。
  > - 还有就是 dp[i - 2]，上 i-2 层楼梯，有 dp[i - 2]种方法，那么再一步跳两个台阶不就是 dp[i]了么。
  > - 那么 dp[i]就是 dp[i - 1]与 dp[i - 2]之和！
- 第三步，初始化 dp[1] = 1，dp[2] = 2

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return n; // 因为下面直接对dp[2]操作了，防止空指针
        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) { // 注意i是从3开始的
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

## 746.使用最小花费爬楼梯

1. dp[i]的定义：到达第 i 台阶所花费的最少体力为 dp[i],不是该台阶需要再往上需要支付的费用
   > `vector<int> dp(cost.size() + 1)`其长度为 cost.size() + 1，所有元素默认初始化为 0（因为 int 的默认构造函数会初始化为 0）。
2. 递归公式：dp[i - 1] 跳到 dp[i] 需要花费 `dp[i - 1] + cost[i - 1]。dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]`。一定是选最小的，所以`dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);`
3. 初始化：`dp[0] = 0，dp[1] = 0`;

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size() + 1);//之所以+1，是因为有楼顶，[0, cost.size() - 1]共cost.size(),再加个楼梯
        dp[0] = 0;
        dp[1] = 0;
        for(int i = 2; i <= cost.size(); i++) {
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp[cost.size()]; //楼顶
    }
};
```

- 优化一下空间，不用 vector

```cpp
// 版本二
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int dp0 = 0;
        int dp1 = 0;
        for (int i = 2; i <= cost.size(); i++) {
            int dpi = min(dp1 + cost[i - 1], dp0 + cost[i - 2]);
            dp0 = dp1; // 记录一下前两位
            dp1 = dpi;
        }
        return dp1;
    }
};
```

## 62.不同路径

- 一些思路：
  > - 用图论里的深搜，来枚举出来有多少种路径
  > - 机器人每次只能向下或者向右移动一步，那么其实机器人走过的路径可以抽象为一棵二叉树，而叶子节点就是终点！此时问题就可以转化为求二叉树叶子节点的个数
  > - 但这个方法是遍历了整个二叉树，时间会超时
- 动态规划
  > - `dp[i][j]` ：表示从（0 ，0）出发，到(i, j) 有 dp[i][j]条不同的路径。
  >   > `vector<vector<int>> dp(m, vector<int>(n, 0));`此句的作用是这样的，（m,n）数组，每一个值为 0,最后一个元素是`dp[m - 1][n - 1]`
  > - 只能有两个方向来推导出来，即`dp[i - 1][j]` 和 `dp[i][j - 1]`。
  > - 如何初始化呢，首先`dp[i][0]`一定都是 1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么`dp[0][j]`也同理。
  >   > ```cpp
  >   > for (int i = 0; i < m; i++) dp[i][0] = 1;
  >   > for (int j = 0; j < n; j++) dp[0][j] = 1;
  >   > ```

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
       vector<vector<int>> dp(m, vector<int>(n, 0));
       for(int i = 0; i < m; i++) dp[i][0] = 1;
       for (int j = 0; j < n; j++) dp[0][j] = 1;
       for(int i = 1; i < m; i++) {//上述为0已经赋值完了，下面从1开始
        for(int j = 1; j < n; j++) {
            dp[i][j] = dp[i-1][j] + dp[i][j - 1];
        }
       }
       return dp[m-1][n-1];
    }
};
```

#### 数论方法

- 在这个图中，可以看出一共 m，n 的话，无论怎么走，走到终点都需要 m + n - 2 步。
- 在这 m + n - 2 步中，一定有 m - 1 步是要向下走的，不用管什么时候向下走。可以转化为，给你 m + n - 2 个不同的数，随便取 m - 1 个数，有几种取法
- 求组合的时候，要防止两个 int 相乘溢出！ 所以不能把算式的分子都算出来，分母都算出来再做除法。
  `下面是错误的`

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
       int fenzi = 1, fenmu = 1;
       int count = m-1;
       int t =m+n-2;
       while(count--) fenzi *= (t--);
       for(int i = 1; i < m-1; i++) {
        fenmu *= i;
       }
       return fenzi/fenmu;
    }
};
```

- 需要在计算分子的时候，不断除以分母，代码如下

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        long long numerator = 1; // 分子
        int denominator = m - 1; // 分母
        int count = m - 1;
        int t = m + n - 2;
        while (count--) {
            numerator *= (t--);
            while (denominator != 0 && numerator % denominator == 0) {
                numerator /= denominator;
                denominator--;
            }
        }
        return numerator;
    }
};
```
## 63.不同路径II
- 有障碍的话，其实就是标记对应的dp table（dp数组）保持初始值(0)就可以了。
- 递推公式：`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`但这里需要注意一点，因为有了障碍，(i, j)如果就是障碍的话应该就保持初始状态（初始状态为0）。
```cpp
if (obstacleGrid[i][j] == 0) { // 当(i, j)没有障碍的时候，再推导dp[i][j]
    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
}
```
- 初始化:因为从(0, 0)的位置到(i, 0)的路径只有一条，所以dp[i][0]一定为1，dp[0][j]也同理。但如果(i, 0) 这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以障碍之后的dp[i][0]应该还是初始值0
```cpp
vector<vector<int>> dp(m, vector<int>(n, 0));
for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
```
```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        if(obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) {
            return 0;//如果在起点或终点出现了障碍，直接返回0
        }
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for(int i = 0; i < m&&obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
        for(int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
         for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if(obstacleGrid[i][j] == 1) continue;
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; 
            }
        }
        return dp[m - 1][n - 1];
    }
};
```
## 343.整数拆分
- dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。
- 确定递推公式:dp[i]最大乘积是怎么得到的呢
   + 1. 拆分成两个数`j * (i - j) `
   + 2. 拆分成三个数及以上`j * dp[i - j]`,没有必要再拆分j,交换律
- dp的初始化`dp[2] = 1`
- 递归式`dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));`
- 注意这里for循环里面`j<i`,不能=，0没有可以拆分的意义。这里也可以优化`j <= i / 2`
```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i <= n ; i++) {
            for (int j = 1; j <= i / 2; j++) {
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
            }
        }
        return dp[n];
    }
};
```