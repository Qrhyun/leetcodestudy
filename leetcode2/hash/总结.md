# hash 总结

## 242 有效的字母异位词

- 数组就是简单的哈希表，但是数组的大小可不是无限开辟的

```cpp
class Solution {
public:
    bool isAnagram(string s,string t){
        int record[26]={0};
        for(int i=0;i<s.size();i++){
            record[s[i]-'a']++;//s[i]-'a'是s[i]的ASCII码减去'a'的ASCII码，得到s[i]在字母表中的位置
        }
        for(int i=0;i<t.size();i++){
            record[t[i]-'a']--;
        }
        for(int i=0;i<26;i++){
            if(record[i]!=0){
                return false;
            }

        }
        return true;
    }
};
```

## 1002.查找常用字符

- 存放结果使用`vector<string>` hash 操作体使用`int hash[]`

```cpp
class Solution {
public:
    vector<string> commonChars(vector<string>& A) {
        vector<string> result;
        if (A.size() == 0)
            return result;
        int hash[26] = {0}; // 1.用来统计所有字符串里字符出现的最小频率并作出初始化

        for (int i = 0; i < A[0].size(); ++i) {
            hash[A[0][i] - 'a']++; // 2. 用第一个字符串给hash初始化
        }

        int hashOtherStr[26] = {0}; // 3.统计除第一个字符串外字符的出现频率

        for (int i = 1; i < A.size(); i++) {
            memset(hashOtherStr, 0, 26 * sizeof(int)); // 并作出初始化
            for (int j = 0; j < A[i].size(); j++) {
                hashOtherStr[A[i][j] - 'a']++; // 4. 再来一个hash
            }

            // 5. 更新hash，保证hash里统计26个字符在所有字符串里出现的最小次数
            for (int k = 0; k < 26; k++) {
                hash[k] = min(hash[k], hashOtherStr[k]);
            }
        }

        // 将hash统计的字符次数，转成输出形式
        for (int i = 0; i < 26; i++) {
            while (hash[i] != 0) {
                string s(1, i + 'a'); // char -> string
                result.push_back(s);
                hash[i]--;
            }
        }

        return result;
    }
};
```

## 349.两个数组的交集

- 交集，重复性问题
  要注意，使用数组来做哈希的题目，是因为题目都限制了数值的大小。
  而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。
  而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。
  此时就要使用另一种结构体了，set ，关于 set，C++ 给提供了如下三种可用的数据结构：

```cpp
std::set
std::multiset
std::unordered_set
```

std::set 和 std::multiset 底层实现都是红黑树，std::unordered_set 的底层实现是哈希表， **使用 unordered_set 读写效率是最高的**，并**不需要对数据进行排序，而且还不要让数据重复**，所以选择 unordered_set。

```cpp
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set;  // 1. 存放结果，之所以用set是为了给结果集去重
        unordered_set<int> nums_set(nums1.begin(), nums1.end());
        for(int num : nums2) {
            // 3. 发现nums2的元素 在nums_set里又出现过
            if(nums_set.find(num) != nums_set.end()) {
                result_set.insert(num);
            }
        }

        return vector<int>(result_set.begin(), result_set.end());
    }
};
```

## 202 题. 快乐数

- 循环重复性问题，还要求很多的数字，使用 unordered_set

```cpp
class Solution {
public:
    // 工具函数，计算sum
    int getSum(int n) {
        int sum = 0;
        while (n) {
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }

    bool isHappy(int n) {
        unordered_set<int> set; // 1.hash操作数组
        while (1) {
            int sum = getSum(n);
            if (sum == 1) {
                return true;
            }

            // 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false
            if (set.find(sum) != set.end()) {
                return false;
            } else {
                set.insert(sum);
            }
            n = sum; // 循环继续进行
        }
    }
};
```

## 1.两数之和

- 当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。
- 本题呢，我就需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。
- 因为本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，需要使用 key value 结构来存放，key 来存元素，value 来存下标，那么使用 map 正合适。
- 再来看一下使用数组和 set 来做哈希法的局限。
  - 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
  - set 是一个集合，里面放的元素只能是一个 key，而两数之和这道题目，不仅要判断 y 是否存在而且还要记录 y 的下标位置，因为要返回 x 和 y 的下标。所以 set 也不能用。
- 此时就要选择另一种数据结构：map ，map 是一种 key value 的存储结构，可以用 key 保存数值，用 value 再保存数值所在的下标。
- 这道题目中并不需要 key 有序，选择 std::unordered_map 效率更高

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        std::unordered_map<int, int> map;
        for (int i = 0; i < nums.size(); ++i) {
            // 业务处理：遍历当前元素，并在map中寻找是否有匹配的key
            auto iter = map.find(target - nums[i]);
            if (iter != map.end()) {
                return {iter->second, i};
            }
            // 如果没找到匹配对，就把访问过的元素和下标加入到map中
            map.insert(pair<int, int>(nums[i], i));
        }
        return {};
    }
};
```