## 704. 二分查找

```c++
// 版本一
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```

## 27. 快慢指针

- 两个指针是为了不用开辟两个 vector, 不用 for 循环两遍
  `错误的写法`

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int low = 0; int fast = 0;
        while(fast <= nums.size() - 1) {
          if(nums[fast] != val) {
            nums[low] = nums[fast];
            low++; fast++;
          }else{
            fast++;
          }
        }
        return low;
    }
};
```

> 报错信息：`runtime error: reference binding to null pointer of type 'int'`
>
> -  **对空 vector 的非法解引用**
> - 代码中 **没有检查 `nums` 是否为空**，就直接访问了 `nums[fast]`（或 `nums[fastIndex]`），当 `nums` 是空 vector 时，`nums.size() - 1` 会变成一个很大的无符号整数（`SIZE_MAX`），导致越界访问。
> - `if (nums.empty()) return 0;`加入

`稳妥的写法是不用fast <= nums.size() - 1,用fast < nums.size()`

- 第二段代码不会触发这个问题，因为 `for (int i = 0; i < nums.size(); ++i)` 在 `nums.size() == 0` 时不会进入循环体。

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (val != nums[fastIndex]) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
};
```

