## 704. 二分查找

```c++
// 版本一
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```
### JZ4 二维数组中的查找
- 从右上角开始查找
- 注意一定要`if(array.empty() || array[0].empty()) return false;`
- 注意`if else if`和`if if`区别太大了
```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param target int整型 
     * @param array int整型vector<vector<>> 
     * @return bool布尔型
     */
    bool Find(int target, vector<vector<int> >& array) {
        int row = 0;
        int col = array[0].size() - 1;
        // if(array.size() == 0 || array[0].size() == 0) {
        //     return false;
        // }
        if(array.empty() || array[0].empty()) return false;
        while((row <= array.size() - 1) && (col >= 0)) {
            if(array[row][col] > target) {
                col--;
            }else if(array[row][col] < target) {
                row++;
            } else {
                return true;
            }
        }
        return false; 
    }
};
```
## 27. 快慢指针

- 两个指针是为了不用开辟两个 vector, 不用 for 循环两遍
  `错误的写法`

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int low = 0; int fast = 0;
        while(fast <= nums.size() - 1) {
          if(nums[fast] != val) {
            nums[low] = nums[fast];
            low++; fast++;
          }else{
            fast++;
          }
        }
        return low;
    }
};
```

> 报错信息：`runtime error: reference binding to null pointer of type 'int'`
>
> - **对空 vector 的非法解引用**
> - 代码中 **没有检查 `nums` 是否为空**，就直接访问了 `nums[fast]`（或 `nums[fastIndex]`），当 `nums` 是空 vector 时，`nums.size() - 1` 会变成一个很大的无符号整数（`SIZE_MAX`），导致越界访问。
> - `if (nums.empty()) return 0;`加入

`稳妥的写法是不用fast <= nums.size() - 1,用fast < nums.size()`

- 第二段代码不会触发这个问题，因为 `for (int i = 0; i < nums.size(); ++i)` 在 `nums.size() == 0` 时不会进入循环体。

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (val != nums[fastIndex]) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
};
```

### 977.有序数组的平方，头尾双指针

- 注意 i <= j,举个例子就知道了

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        vector<int> result(nums.size());
        int k = nums.size() - 1;
        for (int i = 0, j = nums.size() - 1; i <= j; ) {
            if (abs(nums[i]) >= abs(nums[j])) {
                result[k--] = static_cast<long long>(nums[i]) * nums[i];
                i++;
            } else {
                result[k--] = static_cast<long long>(nums[j]) * nums[j];
                j--;  // <-- also fixed this: was j++ (typo)
            }
        }
        return result;
    }
};
```

### 209.长度最小的子数组 滑动窗口

在本题中实现滑动窗口，主要确定如下三点：

> 窗口内是什么？
> 如何移动窗口的起始位置？
> 如何移动窗口的结束位置？

- 窗口就是 满足其和 ≥ s 的长度最小的连续子数组。
- 窗口的起始位置如何移动：如果当前窗口的值大于等于 s 了，窗口就要向前移动了（也就是该缩小了）。
- 窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是 for 循环里的索引。

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int result = INT32_MAX;
        int sum = 0;
        int curlen;
        int i = 0;
        for(int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            while(sum >= target) {
                int curlen = j - i + 1;
                result = result > curlen ? curlen : result;
                sum -= nums[i++];
            }
        }
        if(result == INT32_MAX) return 0;
        else return result;
    }
};
```

### 58. 区间和

- 在输入的过程中，计算前缀和，可以提高效率,prefix[i] 表示 nums[0] 到 nums[i - 1] 的和,即指的是下标为 i 的数的前面那些数字的和。所以一定要弄清楚前缀数组表示什么
- 在输入的过程中 `cin >> nums[i]`，不用再来一次 for 循环专门赋值

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n; cin >> n;
    vector<int> nums(n);
    // 构建前缀和数组
    vector<long long> prefix(n + 1, 0);
    int i = 0;
    // while(n--) {
    //     int num;
    //     cin >> num;
    //     nums[i++] = num;
    // }
    for(int i = 0; i <= n; i++) {
        if(i < n) {
         cin >> nums[i];
        }
        if(i > 0) {
          prefix[i] = prefix[i - 1] + nums[i - 1];
        }
    }
    int a, b;
    while (cin >> a >> b) {
        cout << prefix[b + 1] - prefix[a] << '\n';
    }
    return 0;
}
```

### 44. 开发商购买土地

- 算前缀和的题目，需要按行算完前缀和，再按列算完前缀和
- 同时`for(int i = 0; i < n - 1 ; i++)`，要注意 i 的范围，是 n-1，不是 n,题目要求分割线不能处在开头和结尾
- 注意`rowsum[i] = rowsum[i - 1];`的累加问题

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int n, m; cin >> n >> m;
    //vector<vector<int>> nums(m*n);
    /*
    段错误
    Segmentation fault
    adding: ' white_code[11]=1; ' after judge_client:2836 for :Segmentation fault
    */
    vector<vector<int>> nums(n, vector<int>(m));rowsum[i] = rowsum[i - 1];
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
            cin >> nums[i][j];
        }
    }
    //按行来的前缀和
    vector<int> rowsum(n, 0);
    for(int i = 0; i < n; i++) {
       if(i > 0) {
          rowsum[i] = rowsum[i - 1];
       }
       int j = 0;
       while(j < m) {
        rowsum[i] += nums[i][j++];
       }
    }

    //按列来的前缀和
    vector<int> lensum(m, 0);
    for(int i = 0; i < m; i++) {
       if(i > 0) {
          lensum[i] = lensum[i - 1];
       }
       int j = 0;
       while(j < n) {
        lensum[i] += nums[j++][i];
       }
    }

    int mincha = INT32_MAX;

    //按照行来的划分,这个i表示第几行下面的线
    for(int i = 0; i < n - 1 ; i++) {
        mincha = min(abs(rowsum[i] -
                   rowsum[n - 1] + rowsum[i]), mincha);
    }

    for (int i = 0; i < m - 1; ++i) {
    mincha = min(mincha,
                 abs(lensum[i] - (lensum[m-1] - lensum[i])));
    }
    cout << mincha;

    return 0;
}
```
