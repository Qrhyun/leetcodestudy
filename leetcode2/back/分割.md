## 131.分割回文串
例如对于字符串abcdef：
- 组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个.....。
- 切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段.....。
```cpp
class Solution
{
private:
  // 函数1：判断是否是回文子串.双指针法
  bool isPalindrome(const string &s, int start, int end)
  {
    for (int i = start, j = end; i < j; i++, j--)
    {
      if (s[i] != s[j])
        return false;
    }
    return true;
  }
  vector<vector<string>> result;
  vector<string> path; // 放已经回文的子串
  // 1.确定递归函数的参数和返回值
  void backtracking(const string &s, int startIndex)
  {
    // 2.终止条件,如果起始位置已经大于s的大小，说明已经找到了一组分割方案了
    if (startIndex >= s.size())
    {
      result.push_back(path);
      return;
    }
    // 3.单层递归逻辑
    for (int i = startIndex; i < s.size(); i++)
    {
      // 是回文子串
      if (isPalindrome(s, startIndex, i))
      {
        // 这里借助i++来完成字符串[startIndex,i]的end尾指针的动态增长
        string str = s.substr(startIndex, i - startIndex + 1);
        // substr(startIndex,i-startIndex+1)是从startIndex开始，长度为i-startIndex+1的子串
        path.push_back(str);
      }
      else
      {
        continue; // 不是回文子串，直接跳过下面的程序,继续下一个for循环
      }
      backtracking(s, i + 1); // 递归，注意这里的startIndex是i+1，因为要从下一个位置开始遍历.纵向的逻辑
      path.pop_back();        // 回溯过程，弹出本次已经填在的子串,PATH就是一个动态的
    }
  }

public:
  vector<vector<string>> partition(string s)
  {
    result.clear(); // 清空result，防止结果累积
    path.clear();   // 清空path，防止结果累积
    backtracking(s, 0);
    return result;
  }
};
```
- 优化：具体来说, 给定一个字符串s, 长度为n, 它成为回文字串的充分必要条件是s[0] == s[n-1]且s[1:n-1]是回文字串，如果熟悉动态规划这种算法的话, 我们可以高效地事先一次性计算出, 针对一个字符串s, 它的任何子串是否是回文字串, 然后在我们的回溯函数中直接查询即可, 省去了双指针移动判定这一步骤.
```cpp
class Solution {
private:
    vector<vector<string>> result;
    vector<string> path; // 放已经回文的子串
    vector<vector<bool>> isPalindrome; // 放事先计算好的是否回文子串的结果
    void backtracking (const string& s, int startIndex) {
        // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了
        if (startIndex >= s.size()) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < s.size(); i++) {
            if (isPalindrome[startIndex][i]) {   // 是回文子串
                // 获取[startIndex,i]在s中的子串
                string str = s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
            } else {                                // 不是回文，跳过
                continue;
            }
            backtracking(s, i + 1); // 寻找i+1为起始位置的子串
            path.pop_back(); // 回溯过程，弹出本次已经添加的子串
        }
    }
    void computePalindrome(const string& s) {
        // isPalindrome[i][j] 代表 s[i:j](双边包括)是否是回文字串 
        isPalindrome.resize(s.size(), vector<bool>(s.size(), false)); // 根据字符串s, 刷新布尔矩阵的大小
        for (int i = s.size() - 1; i >= 0; i--) { 
            // 需要倒序计算, 保证在i行时, i+1行已经计算好了
            for (int j = i; j < s.size(); j++) {
                if (j == i) {isPalindrome[i][j] = true;}
                else if (j - i == 1) {isPalindrome[i][j] = (s[i] == s[j]);}
                else {isPalindrome[i][j] = (s[i] == s[j] && isPalindrome[i+1][j-1]);}
            }
        }
    }
public:
    vector<vector<string>> partition(string s) {
        result.clear();
        path.clear();
        computePalindrome(s);
        backtracking(s, 0);
        return result;
    }
};
```
## 93.复原IP地址
- 有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。例如："0.1.2.201" 和 "192.168.1.1" 是 有效的 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效的 IP 地址。
- 本题和上题的区别在于改判断回文子串为判断合法的ip
```cpp
class Solution {
private:
    //判断字串是否合法,判断字符串s在左闭右闭区间[start, end]所组成的数字是否合法
    bool isValid(const string &s, int start, int end) {
         if(start > end) {
            return false;
         }
         if(s[start] == '0' && start != end) { // 0开头的数字不合法,如果是只有一个0，那是合法的
            return false;
         }
         int num = 0;
         for(int i = start; i <= end; i++) {
            if (s[i] > '9' || s[i] < '0') { // 遇到非数字字符不合法
                return false;
            }
            num = num * 10 + (s[i] - '0');
            if (num > 255) { // 如果大于255了不合法
                return false;
            }
         }
         return true;
    }
    vector<string> result;//记录结果
    void backtracking(string &s, int startIndex, int pointNum) {
        //截止条件
        if(pointNum == 3) { // 逗点数量为3时，分隔结束
             // 判断第四段子字符串是否合法，如果合法就放进result中
             if(isValid(s, startIndex, s.size() - 1)) {
                result.push_back(s);
             }
             return;
        }
        for(int i = startIndex; i < s.size(); i++) {
            if(isValid(s,startIndex, i)){
                // 判断 [startIndex,i] 这个区间的子串是否合法
                s.insert(s.begin() + i + 1, '.');// 在i的后面插入一个逗点
                pointNum++;
                backtracking(s, i + 2, pointNum);// 插入逗点之后下一个子串的起始位置为i+2
                pointNum--;                       // 回溯
                s.erase(s.begin() + i + 1);      // 回溯删掉逗点
            }else break; // 不合法，直接结束本层循环
        }
    }
public:
    vector<string> restoreIpAddresses(string s) {
        result.clear();
        if (s.size() < 4 || s.size() > 12) return result; // 算是剪枝了
        backtracking(s, 0, 0);
        return result;
    }
};
```