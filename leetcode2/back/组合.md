## 77.组合
- 要解决 n为100，k为50的情况，暴力写法需要嵌套50层for循环，那么回溯法就用递归来解决嵌套层数的问题
- 可以发现n相当于树的宽度，k相当于树的深度.图中每次搜索到了叶子节点，我们就找到了一个结果.相当于只需要把达到叶子节点的结果收集起来，就可以求得 n个数中k个数的组合集合
```cpp
class Solution
{
private:
  // 1.确定递归函数的参数和返回值

  vector<vector<int>> result; // 存放符合条件结果的集合
  vector<int> path;           // 用来存放符合条件结果.方便后面判断长度到达后，把path加入到result中
  void backtracking(int n, int k, int startIndex)
  {
    // int型变量startIndex，这个参数用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,...,n] ）
    // 2.回溯函数终止条件：什么时候到达叶子节点。path这个数组的大小如果达到k，说明我们找到了一个子集大小为k的组合，在图中path存的就是根节点到叶子节点的路径。
    if (path.size() == k)
    {
      result.push_back(path);
      return; // return是终止当前函数的执行，函数的控制流会立即结束，后续的代码不会被执行。这样就可以完成正确的回溯终止
    }
    // 上面的终止条件一定要在下面的for循环之前，因为如果在for循环之后，就会出现path.size()==k的情况，但是path.size()!=k的情况，这样就会出现错误的结果。
    // 3.单层搜索的过程：回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出for循环用来横向遍历，递归的过程是纵向遍历。
    for (int i = startIndex; i <= n; i++)
    {
      path.push_back(i);         // 处理节点
      backtracking(n, k, i + 1); // 递归
      path.pop_back();           // 回溯，撤销处理的节点
    }
  }

public:
  vector<vector<int>> combine(int n, int k)
  {
    result.clear(); // 清空result，防止上次的结果影响本次的结果
    path.clear();   // 清空path，防止上次的结果影响本次的结果
    // 上述可以不写
    backtracking(n, k, 1);
    return result;
  }
};
```
- 剪枝优化：来举一个例子，n = 4，k = 4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了。如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了
`for (int i = startIndex; i <= n - (k - path.size()) + 1; i++)`

## 216.组合总和III
- 注意调用回溯函数的时候，是`i+1`,不是`startIndex+1`
- 注意不仅要有弹栈压栈的回溯操作，还要sum和也得有加减回溯操作
```cpp
class Solution {
private:
    vector<vector<int>> result; // 存放结果集
    vector<int> path; // 符合条件的结果
    void backtracking(int startIndex, int k, int targetsum, int sum) {
        if(path.size() == k && sum == targetsum) {
            result.push_back(path);
            return;
        }

        for(int i = startIndex; i <= 9; i++) {
            path.push_back(i);
            sum += i;
            backtracking(i + 1, k, targetsum, sum);
            sum -= i;
            path.pop_back();
            
        }
    }

public:
    vector<vector<int>> combinationSum3(int k, int n) {
        result.clear(); // 可以不加
        path.clear();   // 可以不加
        backtracking(1, k, n, 0);
        return result;
    }
};
```
- 已选元素总和如果已经大于n（图中数值为4）了，那么往后遍历就没有意义了，直接剪掉
- 还以剩下元素个数不及凑够n个数的普遍剪枝
```cpp
class Solution {
private:
    vector<vector<int>> result; // 存放结果集
    vector<int> path; // 符合条件的结果
    void backtracking(int startIndex, int k, int targetsum, int sum) {
        if(path.size() == k && sum == targetsum) {
            result.push_back(path);
            return;
        }


        if(sum > targetsum) {
            return; //剪枝操作,这个剪枝是为了剪去sum已经比targetsum大了的情况
        }

        for(int i = startIndex; i <= 9 - (k - path.size()) + 1; i++) {
            path.push_back(i);
            sum += i;
            backtracking(i + 1, k, targetsum, sum);
            sum -= i;
            path.pop_back();
            
        }
    }

public:
    vector<vector<int>> combinationSum3(int k, int n) {
        result.clear(); // 可以不加
        path.clear();   // 可以不加
        backtracking(1, k, n, 0);
        return result;
    }
};
```

## 17.电话号码的字母组合
- `digits[index] - '0' `：这里是由string转化为int的必然，不能因为字符串全是数字就不这么转
- for循环是以一个比如`abc`为基准，开始不断循环的，这里是整个程序的横向参数
- 回溯函数里面的第二个参数不是`i+1`，而是`index+1`,这里要把握的是这个参数是整个程序的纵向参数
```cpp
class Solution {
private:
   const string letterMap[10] = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs", // 7
        "tuv", // 8
        "wxyz", // 9
   };
public:
    vector<string> result;
    string s;
    void backtracking(const string &digits, int index) {
        if(index == digits.size()){
            result.push_back(s);
            return;
        }
        string curstr = letterMap[digits[index] - '0'];
        for(int i = 0; i < curstr.size(); i++) {
            s.push_back(curstr[i]);
            backtracking(digits, index + 1);
            s.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        s.clear();
        result.clear();
        if(digits.size() == 0) {
            return result;
        }
        backtracking(digits, 0);
        return result;
    }
};
```
## 39.组合总和
- 本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。
- 可以理解为前面的是[123]，只能取一次，比如第一次取了1，剩下的只能从[23]里面选择，而本题每轮都可以[123]里面选择
- 关于回溯函数里面传入的参数是i,可以这么理解
```
输入：candidates = [2,3,5], target = 8,
所求解集为： [ [2,2,2,2], [2,3,3], [3,5] ]
可以发现都是递归递增的，比如我可以连着取好几个2，取完2，我可以连着取好几个3
```
```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int> &candidates, int target, int sum, int startIndex) {
        if(sum > target) {
            return;
        }
        if(sum == target) {
            result.push_back(path);
            return;
        }
        for(int i = startIndex; i < candidates.size(); i++) {
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum, i);
            sum -= candidates[i];
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        result.clear();
        path.clear();
        backtracking(candidates, target, 0, 0);
        return result;
    }
};
```
- 对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历
`for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)`
这句比下面这句效率又提高了一点
```
if(sum > target) {
            return;
        }
```