## 准备阶段核心模式

### 1 最小覆盖子串---双指针，使用哈希表可以加速运算

- 先使用一个哈希表（如 Counter）来统计字符串 t 中每个字符需要出现多少次，称为 cnt_t 表示：一个有效子串必须至少包含这些字符和数量。
- 定义两个指针 l 和 r 来表示当前窗口的左右边界（l 是左边界，r 是右边界），窗口的内容就是 s[l:r+1]。
- 使用另一个哈希表 cnt_w 来记录当前窗口中每个字符的数量，方便判断当前窗口是否满足 cnt_t 的要求。
- 从左到右遍历字符串 s，每次将 s[r] 加入窗口并更新 cnt_w，每当我们发现当前窗口 cnt_w 已经满足了 cnt_t 的所有要求，就尝试不断移动左指针 l，看看能不能进一步缩小窗口，从而找到更短的答案。
- 为了判断一个窗口是否满足要求，我们写了一个 check() 函数：遍历 cnt_t 中的所有字符；如果当前窗口中某个字符的数量少于要求，就返回 False；否则说明这个窗口是有效的。

```c++
class Solution {
public:
    unordered_map <char, int> ori, cnt;

    //判断一个窗口里面的所有字符个数是否都大于等于目标字符
    bool check() {
        for(const auto &p: ori) {
            if(cnt[p.first] < p.second) {
                return false;
            }
        }
        return true;
    }

    string minWindow(string s, string t) {
          // 1. 初始化清单map : ori
          for(const auto &c : t) {
            ++ori[c];
          }
          int l = 0, r = -1;
          int len = INT_MAX, ansL = -1, ansR = -1;
          //右指针 r 先走一步，然后把落在窗口里的字符统计到 cnt 中，但只统计那些 t 里出现过的字符
          while(r < int(s.size())) {
            if(ori.find(s[++r]) != ori.end()) {
                ++cnt[s[r]];
            }
            //只要窗口仍满足 t 的所有字符需求，并且左右边界没交叉，就继续收缩左边界。
            while (check() && l <= r) {
                //如果当前窗口长度比已知最短长度更小，则更新最短长度和起始位置。
                //注意如果新窗口长度等于当前最短，条件不成立，变量保持原值，因此不会覆盖。因此最后返回的是最短并且是最左的子串。
                if(r - l + 1 < len) {
                    len = r - l + 1;
                    ansL = l;
                }
                //如果左边界字符 s[l] 是 t 中的字符，则从 cnt 中减少它的计数（因为该字符即将被移出窗口）。
                if(ori.find(s[l]) != ori.end()) {
                    --cnt[s[l]];
                }
                ++l;
            }
          }
        //string()代表“”，因为要求返回string
        return ansL == -1 ? string() : s.substr(ansL, len);
    }
};

```

### 2. 判断字符串是否平衡---类似字符串模拟题

一个字符串是有效的，当满足以下两种情况之一：

1. 所有字符出现次数完全相同；
2. 删除一个字符（即只减少一个字符的出现次数 1 次），剩下的字符出现次数完全相同。
   所以解题思路如下：

- 统计每个字符的出现次数；
- 将这些次数统计成“频率的频率”（frequency of frequencies）；
- 分析这个频率分布，判断是否符合两个规则之一：

```c++
#include <string>
#include <unordered_map>
using namespace std;

class Solution {
public:
  bool isValidString(const string &s) {
   /* 1. 统计每个字符的出现次数 */
   unordered_map<char, int> charCount;
   for(char c : s) {
    ++charCount[c];
   }

   /* 2. 统计“频率的频率” */
   unordered_map<int, int> freqCount;
   for(const auto &kv : charCount) {
    ++freqCount[kv.second];
   }

   /* 3. 分析频率分布 */
   if(freqCount.size() == 1) {
    return true;// 规则1：所有字符出现次数相同
   } else if (freqCount.size() == 2) {
    auto it1 = freqCount.begin();
            auto it2 = next(it1);

            int freq1 = it1->first,  cnt1 = it1->second;
            int freq2 = it2->first,  cnt2 = it2->second;

            // 情况1：某个频率是1且仅出现一次
            if ((freq1 == 1 && cnt1 == 1) || (freq2 == 1 && cnt2 == 1))
                return true;

            // 情况2：两个频率相差1，且较大的那个仅出现一次
            if (abs(freq1 - freq2) == 1) {
                if ((freq1 > freq2 && cnt1 == 1) || (freq2 > freq1 && cnt2 == 1))
                    return true;
            }
   }
   return false;
  }
}
```

### 3. 链表题---模拟题

- K 个一组翻转链表 给你链表的头节点 head，每 k 个节点一组进行翻转，请你返回修改后的链表。k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
- 对于一个子链表，除了翻转其本身之外，还需要将子链表的头部与上一个子链表连接，以及子链表的尾部与下一个子链表连接。因此，在翻转子链表的时候，我们不仅需要子链表头节点 head，还需要有 head 的上一个节点 pre，以便翻转完后把子链表再接回 pre。所以，头节点前面有一个虚拟头节点，也是因为需要用虚拟头节点来记录这部分的头节点。
- 针对链表翻转之后，链表的头节点发生了变化，那么应该返回哪个节点呢？以及如果链表里面没有 k 个节点，答案又还是原来的头节点。我们创建了节点 pre 吗？这个节点一开始被连接到了头节点的前面，而无论之后链表有没有翻转，它的 next 指针都会指向正确的头节点。那么我们只要返回它的下一个节点就好了。

```c++
class Solution {
public:
// 翻转一个子链表，并且返回新的头与尾
    pair<ListNode *, ListNode*> myReverse(ListNode *head, ListNode *tail) {
        ListNode *prev = tail -> next;
        ListNode *p = head;
        while(prev != tail) {
            ListNode *nex = p->next;
            p->next = prev;
            prev = p;
            p = nex;
        }
        return {tail, head};
    }
    ListNode* reverseKGroup(ListNode* head, int k) {
        //虚拟头节点
        ListNode* hair = new ListNode(0);
        hair->next = head;
        //统一pre指针
        ListNode* pre = hair;

        while (head) {
          //尾指针先指向头指针
            ListNode* tail = pre;
            // 查看剩余部分长度是否大于等于 k
            for (int i = 0; i < k; ++i) {
                tail = tail->next;
                if (!tail) {
                    return hair->next;
                }
            }
            ListNode* nex = tail->next;
            // 这里是 C++17 的写法，也可以写成
            // pair<ListNode*, ListNode*> result = myReverse(head, tail);
            // head = result.first;
            // tail = result.second;
            tie(head, tail) = myReverse(head, tail);
            // 把子链表重新接回原链表
            pre->next = head;
            tail->next = nex;
            pre = tail;
            head = tail->next;
        }

        return hair->next;
    }
};
```

### 1.分割等和子集---经典的 hot100 的题目，经典的 01 背包问题

- 题目描述：给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
- 先计算出数组的总和 s，如果总和是奇数，那么一定不能分割成两个和相等的子集，直接返回 false。如果总和是偶数，我们记目标子集的和为 m= 2/s，那么问题就转化成了：是否存在一个子集，使得其元素的和为 m
- 剩下的就是一维数组 01 背包问题解决

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        // dp[i]中的i表示背包内总和
        // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200
        // 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了
        vector<int>dp(10001, 0);
        //求总和
        for(int i = 0; i < nums.size(); i++) {
            sum += nums[i];
        }
        // 也可以使用库函数一步求和
        // int sum = accumulate(nums.begin(), nums.end(), 0);
        if(sum % 2 == 1) return false;
        int target = sum / 2;

        //开始01背包
        for(int i = 0; i < nums.size(); i++) {
            for(int j = target; j >= nums[i]; j--) {
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        if(dp[target] == target) return true;
        return false;
    }
};
```

### 2. 数字比较游戏----基础的字符串处理，使用哈希表统计即可

- 请注意 num1 和 num2 都可能含有重复数字，num1 和 num2 中每位数字只能统计一次。

```c++
#include <vector>
#include <string>
#include <unordered_map>
using namespace std;

class Solution {
public:
   string NumCompare(const string &num1, const string &num2) {
     int n = num1.size();
     int A = 0, B = 0;

     vector<bool> match1(n, false), match2(n, false);// 标记 num1 , num2中哪些位已配对
      /* 1. 先找 A —— 数字和位置都正确 */
      for(int i = 0; i < n; i++) {
        if(num1[i] == num2[i]) {
          A++;
          match1[i] = match2[i] = true;
        }
      }

      /* 2. 把未被 A 匹配的数字分别收集起来 */
      string rem1, rem2;
      for(int i = 0; i < n; i++) {
        if(!match1[i]) rem1.push_back(num1[i]);
        if(!match2[i]) rem2.push_back(num2[i]);
      }

      /* 3. 用哈希表统计 rem1 中每个数字的出现次数 */
      unordered_map<char, int> freq;
      for(char c : rem1) ++freq[c];

       /* 4. 遍历 rem2，每匹配一个就减 1，避免重复计数 */
       for(char C : rem2) {
        if(freq[c] > 0) {
          ++B;
          --freq[c];
        }
       }
       /* 5. 按题目要求格式化成字符串返回 */
       return to_string(A) + "A" + to_string(B) + "B";
   }
};
```

### 3. 找出最低的测试成本是多少---贪心的应用，需要使用堆来获取当前最小的两个模块，并动态维护堆

- 将所有测试用例数放入最小堆。每次从堆里取出两个最小的数，相加得到 “合并成本”，累加到总结果里.把相加后的结果重新放入堆，重复步骤 2，直到堆中只剩一个数。
- 等价于「合并石子」或「文件拼接」问题

```c++
#include <vector>
#include <queue>
using namespace std;

class Solution {
public:
  long long minEffort(vector<int> &cases) {
     long long totalCost = 0;
     /* 1. 用最小堆（priority_queue 默认是大顶堆，需要自定义比较器） */
     priority_queue<long long, vector<long long>, greater<long long>> minHeap;

     /* 2. 把所有测试用例数压入堆 */
     for(int x : cases) {
      minHeap.push(x);
     }

     /* 3. 只要堆中元素多于 1 个，就继续合并 */
     while(minHeap.size() > 1) {
      long long a = minHeap.top(); minHeap.pop();
      long long b = minHeap.top(); minHeap.pop();
      long long cost = a + b;
      totalCost += cost;
      minHeap.push(cost);
     }
      return totalCost;
  }
};
```

```md
`priority_queue<long long, vector<long long>, greater<long long>> minHeap;`  
这一行代码一次性声明了一个 **最小堆**（min-heap）。把它拆成三段来看就非常清晰。

------------------------------------------------
1. `priority_queue< … >`  
   这是 C++ STL 里的“优先队列”模板。  
   默认情况下，它其实是一个**大顶堆**（max-heap），即**最大的元素永远在堆顶**。  
   如果你需要小顶堆（最小的元素在堆顶），就必须手动指定模板参数。

------------------------------------------------
2. 模板参数三件套  
   ```
   priority_queue<
       long long,                      // (1) 存储的元素类型
       vector<long long>,              // (2) 底层容器类型
       greater<long long>              // (3) 比较器 / 排序规则
   >
   ```
   - (1) `long long`  
     表示堆里放的是 64 位整数。  
   - (2) `vector<long long>`  
     告诉 `priority_queue` 用 `vector` 作为底层存储结构（默认就是 `vector`，但这里显式写出来）。  
   - (3) `greater<long long>`  
     这是关键！`greater<T>` 是一个 **函数对象（仿函数）**，它对两个 `long long` 值执行 “>” 比较。  
     因为 STL 默认用 `less<T>`（相当于“<”）产生大顶堆，而 `greater<T>` 正好相反，于是得到 **小顶堆**。

------------------------------------------------
3. 变量名 `minHeap`  
   只是一个变量名，用来表示“这是一个最小堆”。

------------------------------------------------
等价关系速记
- 默认大顶堆：`priority_queue<long long>`  
- 显式大顶堆：`priority_queue<long long, vector<long long>, less<long long>>`  
- 最小堆（小顶堆）：`priority_queue<long long, vector<long long>, greater<long long>>`

------------------------------------------------
最小堆常用接口
- `minHeap.push(x);`        // 把 x 压入堆，O(log n)  
- `minHeap.top();`          // 取最小值（堆顶），O(1)  
- `minHeap.pop();`          // 弹出堆顶，O(log n)  
- `minHeap.empty();`        // 判空  
- `minHeap.size();`         // 元素个数

一行声明，三件事全部搞定：元素类型、底层容器、比较器，于是得到一个真正可用的最小堆。
```

````markdown
在 C++ 里，除了  
`priority_queue<long long, vector<long long>, greater<long long>>`  
这种“最小堆”写法之外，常见的“还能怎么写”大致分三类：  

1. 用别的容器当底层  
2. 用别的比较器（仿函数 / lambda / 函数指针）  
3. 干脆不用 `priority_queue`，换别的堆实现  

下面把常见“可选项”一次性列给你，并给出示例代码与适用场景。  

------------------------------------------------  
一、底层容器可以换成别的  
`std::priority_queue` 第二个模板参数只要满足 **顺序容器 + 随机访问迭代器** 即可。  
- `vector`（默认，也是最常用）  
- `deque`  

示例：  
```cpp
#include <queue>
#include <deque>
std::priority_queue<int, std::deque<int>, std::greater<int>> min_heap_deque;
```
注意：`list`、`forward_list` 不行，因为它们没有随机访问迭代器。  

------------------------------------------------  
二、比较器可以换成别的三种写法  

1. 标准库自带仿函数  
   - `std::less<T>`（默认，大顶堆）  
   - `std::greater<T>`（小顶堆）  

2. 自定义结构体 / 仿函数  
```cpp
struct MyComp {
    bool operator()(const long long& a, const long long& b) const {
        return a > b;          // 小顶堆
    }
};
std::priority_queue<long long, std::vector<long long>, MyComp> min_heap;
```

3. C++11 起可直接写 lambda（需要借助 `decltype` + 构造实参）  
```cpp
auto cmp = [](const long long& a, const long long& b) { return a > b; };
std::priority_queue<long long, std::vector<long long>, decltype(cmp)> min_heap(cmp);
```

4. 函数指针（不推荐，语法啰嗦且容易出错）  
```cpp
bool (*fp)(long long, long long) = [](long long a, long long b){ return a > b; };
std::priority_queue<long long, std::vector<long long>, bool(*)(long long,long long)> min_heap(fp);
```

------------------------------------------------  
三、干脆不用 `std::priority_queue`  

1. 直接调 `std::make_heap / push_heap / pop_heap`（手动维护 vector）  
   好处：可以灵活改比较器、可以把同一个 vector 反复当堆 / 非堆用。  
```cpp
vector<long long> v = {4, 3, 6, 1};
make_heap(v.begin(), v.end(), greater<long long>());   // 小顶堆
// 推入新元素
v.push_back(2);
push_heap(v.begin(), v.end(), greater<long long>());
```

2. Boost 容器  
   `#include <boost/heap/d_ary_heap.hpp>`  
   Boost 提供二叉堆、斐波那契堆、配对堆等，接口更丰富，适合竞赛或高性能场景。  
```cpp
#include <boost/heap/d_ary_heap.hpp>
using min_heap = boost::heap::d_ary_heap<long long,
                                         boost::heap::arity<2>,
                                         boost::heap::compare<std::greater<long long>>>;
```

3. 自己手写二叉堆 / 配对堆 / 斜堆  
   教学、刷题、嵌入式环境常用，完全可控。

------------------------------------------------  
速查表：一句看懂各种写法

| 写法 | 堆类型 | 是否 STL | 备注 |
|---|---|---|---|
| `priority_queue<int>` | 大顶堆 | 是 | 默认 |
| `priority_queue<int, vector<int>, greater<int>>` | 小顶堆 | 是 | 一行搞定 |
| `priority_queue<int, deque<int>, greater<int>>` | 小顶堆 | 是 | 换底层容器 |
| 自定义结构体仿函数 | 任意规则 | 是 | 灵活 |
| lambda + decltype | 任意规则 | 是 | C++11+ |
| `make_heap` 系列 | 任意规则 | 是 | 手动维护 |
| Boost.heap | 多种堆 | 否 | 高性能 |
| 手写堆 | 任意 | 否 | 完全可控 |

一句话总结：  
`greater<long long>` 只是 STL 自带的小顶堆“快捷方式”；你可以换容器、换比较器，甚至完全不用 `priority_queue`，按场景选择即可。

````

### 1. 反转字符串中的小写字母---字符串处理双指针
- 这是真个字符串进行反转
```c++
#include <iostream>
#include <string>
#include <cctype>
using namespace std;

string reverseLowercase(const string &s) {
  string t = s;//复制一份字符串，因为题目要求“其他字符位置不变”，直接修改原串会不安全。

  int l = 0, r = t.size() - 1;// 双指针，分别从两端向中间扫描

  while(l < r) {
    if(!islower(t[l])) {
      ++l;
    }else if(!islower(t[r])) {
      --r;
    }else {
      //当左右指针都指向小写字母时，交换它们，然后把两个指针各自向中间移动一步。
      swap(t[l], t[r]);
      ++l;
      --r;
    }
  }
  return t;
}

int main() {
  string line; getline(cin, line);
  cout << reverseLowercase(line) << endl;
  return 0;
}
```
- 这是仅仅每个字符串进行独立反转
```c++
#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>
using namespace std;

string reverseLowerInWord(const string &w) {
  string t = w;
  int l = 0, r = (int)t.size() - 1;
  while(l < r) {
    if(!islower(t[l])) {
      ++l;
    } else if(!islower(t[r])) {
      --r;
    } else {
      swap(t[l], t[r]);
      ++l;
      --r;
    }
  }
  return t;
}

int main() {
  string line;
  getline(cin, line);          // 读整行，保留空格

  string res;
  size_t i = 0, n = line.size();

  while (i < n) {
    if (isspace(line[i])) {                       // 空白区间
      size_t j = i;
      while (j < n && isspace(line[j])) ++j;
      res.append(line, i, j - i);                 // 原样追加
      i = j;
    } else {                                      // 单词区间
      size_t j = i;
      while (j < n && !isspace(line[j])) ++j;
      string word = line.substr(i, j - i);
      res += reverseLowerInWord(word);            // 反转小写后追加
      i = j;
    }
  }

  cout << res << '\n';
  return 0;
}
```
### 一次买卖股票的最佳时机---动态规划股票基础问题
- dp[i][0]表示第i天持有股票所得最多现金，这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？其实一开始现金是0，那么加入第i天买入股票现金就是 -prices[i]， 这是一个负数。dp[i][1] 表示第i天不持有股票所得最多现金。注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态。那么结果是max(dp[n - 1][0], dp[n - 1][1]);
- 递推公式：dp[n][0] = max(dp[n - 1][0], -prices[n]); dp[n][1] = max(dp[n - 1][1], dp[n - 1][0] + price[i])
- 初始化： dp[0][0] = -price[0]; dp[0][1] = 0;
- 遍历顺序：从前往后
```c++
class Solution {
public:
   int maxProfit(vector<int> & prices) {
     int len = price.size();
     if(len == 0) return 0;
     vector<vector<int>> dp(len, vector<int>(2));
     dp[0][0] = -prices[0];
     dp[0][1] = 0;
     for(int i = 1; i < len; ++i) {
       dp[i][0] = max(dp[i - 1][0], -prices[i]);
       dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
     }
     return dp[len - 1][1];//注意最后一定是所有股票都脱手的
   }
}
```
### 卡车运货问题---动态规划:“恰好装满背包”的 0/1 背包问题
- 问题描述：有一批货物要运输，已知卡车的载重量为W，其中集装箱i（1<=i<=n）的重量为w[i]，n为集装箱个数，在不考虑集装箱体积的前提下，尽量多的将集装箱放到卡车上，使集装箱的重量之和正好等于W，当总重量相同时，要求选取的集装箱个数尽可能少，请给出最优的集装箱选择方案。
```c++
todo......
```

### 找出字符串中第一个匹配的下标kmp算法