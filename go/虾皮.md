## 准备阶段核心模式

### 1 最小覆盖子串---双指针，使用哈希表可以加速运算

- 先使用一个哈希表（如 Counter）来统计字符串 t 中每个字符需要出现多少次，称为 cnt_t 表示：一个有效子串必须至少包含这些字符和数量。
- 定义两个指针 l 和 r 来表示当前窗口的左右边界（l 是左边界，r 是右边界），窗口的内容就是 s[l:r+1]。
- 使用另一个哈希表 cnt_w 来记录当前窗口中每个字符的数量，方便判断当前窗口是否满足 cnt_t 的要求。
- 从左到右遍历字符串 s，每次将 s[r] 加入窗口并更新 cnt_w，每当我们发现当前窗口 cnt_w 已经满足了 cnt_t 的所有要求，就尝试不断移动左指针 l，看看能不能进一步缩小窗口，从而找到更短的答案。
- 为了判断一个窗口是否满足要求，我们写了一个 check() 函数：遍历 cnt_t 中的所有字符；如果当前窗口中某个字符的数量少于要求，就返回 False；否则说明这个窗口是有效的。

```c++
class Solution {
public:
    unordered_map <char, int> ori, cnt;

    //判断一个窗口里面的所有字符个数是否都大于等于目标字符
    bool check() {
        for(const auto &p: ori) {
            if(cnt[p.first] < p.second) {
                return false;
            }
        }
        return true;
    }

    string minWindow(string s, string t) {
          // 1. 初始化清单map : ori
          for(const auto &c : t) {
            ++ori[c];
          }
          int l = 0, r = -1;
          int len = INT_MAX, ansL = -1, ansR = -1;
          //右指针 r 先走一步，然后把落在窗口里的字符统计到 cnt 中，但只统计那些 t 里出现过的字符
          while(r < int(s.size())) {
            if(ori.find(s[++r]) != ori.end()) {
                ++cnt[s[r]];
            }
            //只要窗口仍满足 t 的所有字符需求，并且左右边界没交叉，就继续收缩左边界。
            while (check() && l <= r) {
                //如果当前窗口长度比已知最短长度更小，则更新最短长度和起始位置。
                //注意如果新窗口长度等于当前最短，条件不成立，变量保持原值，因此不会覆盖。因此最后返回的是最短并且是最左的子串。
                if(r - l + 1 < len) {
                    len = r - l + 1;
                    ansL = l;
                }
                //如果左边界字符 s[l] 是 t 中的字符，则从 cnt 中减少它的计数（因为该字符即将被移出窗口）。
                if(ori.find(s[l]) != ori.end()) {
                    --cnt[s[l]];
                }
                ++l;
            }
          }
        //string()代表“”，因为要求返回string
        return ansL == -1 ? string() : s.substr(ansL, len);
    }
};

```

### 2. 判断字符串是否平衡---类似字符串模拟题

一个字符串是有效的，当满足以下两种情况之一：

1. 所有字符出现次数完全相同；
2. 删除一个字符（即只减少一个字符的出现次数 1 次），剩下的字符出现次数完全相同。
   所以解题思路如下：

- 统计每个字符的出现次数；
- 将这些次数统计成“频率的频率”（frequency of frequencies）；
- 分析这个频率分布，判断是否符合两个规则之一：

```c++
#include <string>
#include <unordered_map>
using namespace std;

class Solution {
public:
  bool isValidString(const string &s) {
   /* 1. 统计每个字符的出现次数 */
   unordered_map<char, int> charCount;
   for(char c : s) {
    ++charCount[c];
   }

   /* 2. 统计“频率的频率” */
   unordered_map<int, int> freqCount;
   for(const auto &kv : charCount) {
    ++freqCount[kv.second];
   }

   /* 3. 分析频率分布 */
   if(freqCount.size() == 1) {
    return true;// 规则1：所有字符出现次数相同
   } else if (freqCount.size() == 2) {
    auto it1 = freqCount.begin();
            auto it2 = next(it1);

            int freq1 = it1->first,  cnt1 = it1->second;
            int freq2 = it2->first,  cnt2 = it2->second;

            // 情况1：某个频率是1且仅出现一次
            if ((freq1 == 1 && cnt1 == 1) || (freq2 == 1 && cnt2 == 1))
                return true;

            // 情况2：两个频率相差1，且较大的那个仅出现一次
            if (abs(freq1 - freq2) == 1) {
                if ((freq1 > freq2 && cnt1 == 1) || (freq2 > freq1 && cnt2 == 1))
                    return true;
            }
   }
   return false;
  }
}
```
### 3. 链表题---模拟题
- K个一组翻转链表 给你链表的头节点head，每k个节点一组进行翻转，请你返回修改后的链表。k是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是k的整数倍，那么请将最后剩余的节点保持原有顺序。
- 对于一个子链表，除了翻转其本身之外，还需要将子链表的头部与上一个子链表连接，以及子链表的尾部与下一个子链表连接。因此，在翻转子链表的时候，我们不仅需要子链表头节点 head，还需要有 head 的上一个节点 pre，以便翻转完后把子链表再接回 pre。所以，头节点前面有一个虚拟头节点，也是因为需要用虚拟头节点来记录这部分的头节点。
- 针对链表翻转之后，链表的头节点发生了变化，那么应该返回哪个节点呢？以及如果链表里面没有 k 个节点，答案又还是原来的头节点。我们创建了节点 pre 吗？这个节点一开始被连接到了头节点的前面，而无论之后链表有没有翻转，它的 next 指针都会指向正确的头节点。那么我们只要返回它的下一个节点就好了。
```c++
class Solution {
public:
// 翻转一个子链表，并且返回新的头与尾
    pair<ListNode *, ListNode*> myReverse(ListNode *head, ListNode *tail) {
        ListNode *prev = tail -> next;
        ListNode *p = head;
        while(prev != tail) {
            ListNode *nex = p->next;
            p->next = prev;
            prev = p;
            p = nex;
        }
        return {tail, head};
    }
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* hair = new ListNode(0);
        hair->next = head;
        ListNode* pre = hair;

        while (head) {
            ListNode* tail = pre;
            // 查看剩余部分长度是否大于等于 k
            for (int i = 0; i < k; ++i) {
                tail = tail->next;
                if (!tail) {
                    return hair->next;
                }
            }
            ListNode* nex = tail->next;
            // 这里是 C++17 的写法，也可以写成
            // pair<ListNode*, ListNode*> result = myReverse(head, tail);
            // head = result.first;
            // tail = result.second;
            tie(head, tail) = myReverse(head, tail);
            // 把子链表重新接回原链表
            pre->next = head;
            tail->next = nex;
            pre = tail;
            head = tail->next;
        }

        return hair->next;
    }
};
```