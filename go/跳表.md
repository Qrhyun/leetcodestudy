跳表（Skip List）是一种**概率型**的**有序链表**快速查找结构，通俗地说：  
> 把有序的链表**分层造“索引”**，让每次查找能**跳过大量节点**，平均时间复杂度做到 **O(log n)**，实现简单，还能方便地做并发。

------------------------------------------------
1. 直观例子  
   假设你把 1→3→7→12→20→25 这一根普通有序链表存下来：

   第 0 层（原始链表）：  
   HEAD  ↔ 1 ↔ 3 ↔ 7 ↔ 12 ↔ 20 ↔ 25

   现在随机地把其中一些节点**“复制”到上一层**，并继续往后指：

   第 1 层（索引层）：  
   HEAD --------------→ 7 -----------→ 25

   第 2 层（再抽稀）：  
   HEAD ------------------------------→ 25

   查找 20 时：  
   - 从顶层 HEAD 开始，右跳到 25，发现 25 > 20，**退一层**；  
   - 在第 1 层 7 处向右到 25，25 > 20，**退一层**；  
   - 在第 0 层 7 处向右顺序扫描 12→20，命中。  

   只走了 4 步，而原始链表需要 6 步；数据量越大，跳过的节点越多。

------------------------------------------------
2. 正式定义  
   - 每层都是一个**有序链表**，最底层（第 0 层）包含所有元素。  
   - 上层是下层的**子集**，用**随机函数**决定一个节点要不要“长高”一层，常用概率 p = 0.5。  
   - 平均期望层数 = 1/(1-p) ≈ 2，最坏层数 O(log n)。  
   - 查找、插入、删除 都先“向右→向下”走，**过程可逆**，实现无锁或细粒度锁都比较容易。

------------------------------------------------
3. 复杂度  
   | 操作 | 平均     | 最坏 | 说明                       |
   | ---- | -------- | ---- | -------------------------- |
   | 查找 | O(log n) | O(n) | 随机极坏情况全部退化到一层 |
   | 插入 | O(log n) | O(n) | 先查找再改指针             |
   | 删除 | O(log n) | O(n) | 同理                       |

   空间：  
   期望 O(n) 额外指针，p=0.5 时约 2n 个指针，和普通链表同一量级。

------------------------------------------------
4. 跟平衡搜索树的对比  
   | 维度       | 跳表                     | 红黑树/AVL               |
   | ---------- | ------------------------ | ------------------------ |
   | 实现难度   | 极简单，几十行代码       | 需要旋转、颜色管理       |
   | 并发友好   | 可 lock-free/细粒度锁    | 再平衡期间需整棵子树加锁 |
   | 范围查询   | 链表顺序遍历，天然友好   | 需要中序遍历，略复杂     |
   | 内存局部性 | 指针跳跃多，Cache 不友好 | 树节点紧凑，稍好         |
   | 确定性     | 概率型，最坏 O(n)        | 严格 O(log n)            |

   因此：**内存型、需要高并发、代码易维护** 的场景偏爱跳表，例如：

------------------------------------------------
5. 工业级应用  
   - Redis 的 **ZSET**（有序集合）用跳表 + dict 双结构，支持按 score 范围取 TOP N。  
   - LevelDB/RocksDB 的 **MemTable** 用跳表保存刚写入的 KV，保证内存里有序。  
   - Lucene 早期版本用跳表做倒排链的合并。  
   - 大量并发 Map 实现（Java ConcurrentSkipListMap）也是跳表。

------------------------------------------------
6. 最小可运行 Python 版  
   ```python
   import random
   class Node:
       def __init__(self, val, level):
           self.val = val
           self.next = [None]*level   # 每层一个前向指针
   
   class SkipList:
       def __init__(self, max_level=16, p=0.5):
           self.max_level = max_level
           self.p = p
           self.header = Node(None, max_level)
           self.level = 1                          # 当前最高层
   
       def random_level(self):
           lvl = 1
           while random.random() < self.p and lvl < self.max_level:
               lvl += 1
           return lvl
   
       def find(self, target):
           curr = self.header
           for l in reversed(range(self.level)):
               while curr.next[l] and curr.next[l].val < target:
                   curr = curr.next[l]
           curr = curr.next[0]
           return curr and curr.val == target
   
       def insert(self, val):
           update = [None]*self.max_level
           curr = self.header
           for l in reversed(range(self.level)):
               while curr.next[l] and curr.next[l].val < val:
                   curr = curr.next[l]
               update[l] = curr
           new_level = self.random_level()
           if new_level > self.level:
               for l in range(self.level, new_level):
                   update[l] = self.header
               self.level = new_level
           node = Node(val, new_level)
           for l in range(new_level):
               node.next[l] = update[l].next[l]
               update[l].next[l] = node
   
       def __str__(self):
           # 简易打印
           res = []
           for l in reversed(range(self.level)):
               line = []
               curr = self.header.next[l]
               while curr:
                   line.append(str(curr.val))
                   curr = curr.next[l]
               res.append('Level '+str(l)+': '+' '.join(line))
           return '\n'.join(res)
   
   if __name__ == '__main__':
       sl = SkipList()
       for v in [3, 6, 7, 9, 12, 19, 17]:
           sl.insert(v)
       print(sl)
       print('find 9:', sl.find(9))
       print('find 15:', sl.find(15))
   ```

------------------------------------------------
7. 一句话总结  
跳表 = **有序链表 + 多级随机索引**，用概率换简单，**写起来像链表、跑起来像平衡树**，在**高并发、内存、范围查询**场景特别吃香。