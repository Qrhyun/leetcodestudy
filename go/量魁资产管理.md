## 笔试

### delete 和 delete[]

- `delete`：用于释放**单个对象**（由 `new` 分配）。
- `delete[]`：用于释放**对象数组**（由 `new[]` 分配）。

### lock_guard 和 unique_lock

你可能是想说：

- `std::lock_guard`
- `std::unique_lock`

（没有 `unique_guard` 这个标准库类型）

---

######  一句话区别：

| 特性         | `std::lock_guard`    | `std::unique_lock`                   |
| ------------ | -------------------- | ------------------------------------ |
| 灵活性       | ❌ 简单、不可手动解锁 | ✅ 可手动 `lock()` / `unlock()`       |
| 性能         | ✅ 更轻量             | ❌ 稍重（多存状态）                   |
| 支持延迟加锁 | ❌ 不支持             | ✅ 支持 `std::defer_lock`             |
| 支持条件变量 | ❌ 不行               | ✅ 可以配合 `std::condition_variable` |
| 可移动       | ❌ 不可               | ✅ 可移动（moveable）                 |

---

###### 使用场景建议：

| 场景                         | 推荐               |
| ---------------------------- | ------------------ |
| 简单临界区，自动加锁/解锁    | `std::lock_guard`  |
| 需要手动控制锁、配合条件变量 | `std::unique_lock` |

---

###### 示例对比：

 `std::lock_guard`：简单自动管理

```cpp
std::mutex mtx;
{
    std::lock_guard<std::mutex> lock(mtx);
    // 自动加锁，出作用域自动解锁
}
```

 `std::unique_lock`：更灵活

```cpp
std::mutex mtx;
std::unique_lock<std::mutex> lock(mtx, std::defer_lock); // 不立刻加锁
// 稍后再加锁
lock.lock();
// 手动解锁
lock.unlock();
```

---

###### 总结一句话：

> **简单用 `lock_guard`，复杂用 `unique_lock`。**

### thread 创建后，如果没有调用 join detach 会发生什么

在 C++ 中，**`std::thread` 对象被析构时，如果它仍然表示一个“可 join”的线程（即既没 `join()` 也没 `detach()`），程序会直接 `std::terminate()` —— 进程异常终止。**

---

##### 标准规则（C++11 起）：

> **析构线程对象前，必须且只能做一次：**  
> `join()` **或** `detach()`，否则 `std::terminate()` 被调用。

---

##### 示例：错误代码

```cpp
#include <thread>
void foo() {}

int main() {
    std::thread t(foo);
    // 既没 t.join() 也没 t.detach()
}   // t 析构 → std::terminate() → 程序崩溃
```

运行结果：**程序异常终止**，编译器不会报错，但运行期直接 `abort`。

---

##### 正确写法 1：等待线程结束

```cpp
std::thread t(foo);
t.join();   // 主线程等待子线程结束
```

##### 正确写法 2：后台运行

```cpp
std::thread t(foo);
t.detach(); // 子线程与主线程分离，后台运行
```

---

##### 注意：

- `join()` 只能调用一次。
- `detach()` 后，**不能再 `join()`**，也**无法再通过该 `std::thread` 对象控制线程**。
- 如果忘记 `join/detach`，**编译器不会警告你**，但运行期直接 `terminate()`。

---

##### 最佳实践（RAII 包装）

用 RAII 包装器自动 `join` 或 `detach`，避免忘记：

```cpp
class scoped_thread {
    std::thread t;
public:
    explicit scoped_thread(std::thread th) : t(std::move(th)) {
        if (!t.joinable()) throw std::logic_error("Not joinable");
    }
    ~scoped_thread() { t.join(); }  // 自动 join
    scoped_thread(scoped_thread&&) = default;
    scoped_thread& operator=(scoped_thread&&) = default;
};
```

---

##### 总结一句话：

> **线程对象析构前，必须 `join()` 或 `detach()`，否则程序直接 `terminate()`。**

---

如果你有具体代码片段，我可以帮你检查是否安全。

### lambda 如何捕获

- **外部变量** ⇨ **定义在 lambda 所在作用域之外**的变量（即需要“捕获”才能用）。
- **内部变量** ⇨ **定义在 lambda 体内**的局部变量，跟普通函数一样，**不用、也不能捕获**

在 C++ 里，lambda 的“捕获”就是把**外部作用域的变量**拿进来，让 lambda 体里能用。  
语法在 `[]` 里写，分成“**按值捕获**”“**按引用捕获**”两大类，还能混用、加修饰符。

---

##### 1. 按值捕获（默认只读）

```cpp
int a = 1, b = 2;
auto f = [a, b]() { return a + b; };   // 把 a、b 各拷一份进来
a = 10;
std::cout << f(); // 3  （a 的副本仍是 1）
```

---

##### 2. 按引用捕获（可改外部对象）

```cpp
int a = 1;
auto f = [&a]() { ++a; };  // 捕获 a 的引用
f();
std::cout << a; // 2
```

---

##### 3. 一次性捕获所有

| 写法  | 含义                                 |
| ----- | ------------------------------------ |
| `[=]` | **全部按值**捕获当前作用域可见变量   |
| `[&]` | **全部按引用**捕获当前作用域可见变量 |

```cpp
int x = 1, y = 2;
auto f1 = [=]() { return x + y; };  // 各拷一份
auto f2 = [&]() { x += y; };        // 都是引用
```

---

##### 4. 混合捕获（先写默认，再列例外）

```cpp
int a = 1, b = 2, c = 3;
auto f = [&, a]() {        // 默认全部引用，但 a 按值
    // b、c 是引用，a 是副本
};
```

---

##### 5. 带初始化器的“自定义”捕获（C++14）

可以**当场新建变量**并捕获，甚至 move 唯一对象：

```cpp
auto u = std::make_unique<int>(10);
auto f = [v = std::move(u)]() { return *v; };  // 把 unique_ptr 移进来
```

---

##### 6. 修饰符（C++11 起）

- `[=, &x]` 合法  
- `[&, x]` 合法  
- `[x, &x]` **非法**，重复  
- 默认捕获后再单独列变量时，**变量必须写在后面**。

---

##### 7. 捕获 this（成员函数里）

```cpp
struct S {
    int val = 42;
    void foo() {
        auto f = [this]() { return val; };  // 捕获 this 指针
    }
};
```

C++20 起可用 `[=, this]` 或 `[&, this]` 显式写；  
C++20 还引入 `[=, *this]` 按值捕获 **整个对象副本**。

### 文件流对象在什么时候自动关闭文件

**`std::fstream` 对象在两种时刻会自动关闭文件：**

1. **析构函数执行时**（离开作用域、被 `delete`、容器销毁等）。
2. **你显式调用 `.close()` 后**（虽然这是手动触发，但底层逻辑一样）。

除此之外，**不会**因为一次读写结束、到达文件尾、抛异常等而“悄悄”关闭。

| 场景                     | 文件是否自动关闭 | 备注                        |
| ------------------------ | ---------------- | --------------------------- |
| 离开作用域               | ✅                | 析构保证                    |
| 容器 `clear()`/`erase()` | ✅                | 元素析构                    |
| 抛异常导致栈回溯         | ✅                | 栈展开照样析构              |
| 到达 EOF                 | ❌                | 仅设置 `eofbit`，文件仍开着 |
| 赋值新对象给旧对象       | ✅                | 旧对象先析构                |
| 手动 `.close()`          | ✅                | 你主动触发，同样一次关闭    |

**结论：只要 `fstream` 对象活着，文件就保持打开；对象死亡，文件必关。**

### 基类和派生类哪个先构造

**基类永远先于派生类构造；析构顺序严格相反——派生类先析构，基类后析构。**

1. 按继承表从左到右，**逐级构造基类**（多继承同理）。
2. 按声明顺序，**构造成员对象**。
3. 最后执行**派生类自身构造函数体**。

### 想提高 unordered_map 查询性能

提高 `unordered_map` 查询性能，**90% 的场景只改三件事**：

1. 选**好哈希函数**（减少碰撞）  
2. **reserve** 足够桶数（减少 rehash）  
3. **自定义 equal_to** 用指针/整数比较（减少 key 比对开销）

下面给一条“检查清单”，按代价从低到高排序，拿来即用。

------------------------------------------------
① 预分配桶数 → 去掉运行时 rehash  
```cpp
std::unordered_map<Key, Val> m;
m.reserve(预计元素数);   // 只一次，后续插入不再 rehash
```

------------------------------------------------
② 让 key 哈希值“廉价”且分布均匀  
- 内置类型已最优；  
- `string` 当 key 却只做 **exact match** 时，直接存  
  `std::string_view` 或 `const char*` 避免深拷贝；  
- 大对象用 **“哈希缓存”** 技术（C++20 起 `std::hash<std::string>` 已自带，老编译器可手写）。

------------------------------------------------
③ 自定义哈希 / 相等判定，减少桶内比对  
```cpp
struct Fnv1a {
    std::size_t operator()(const std::string& s) const noexcept {
        std::size_t h = 14695981039346656037u;
        for (unsigned char c : s) {
            h ^= c;
            h *= 1099511628211u;
        }
        return h;
    }
};
using fast_map = std::unordered_map<std::string, int, Fnv1a>;
```

------------------------------------------------
④ 整数 key 但范围连续？换 **flat_map**  
`unordered_map` 每次查询至少一次哈希 + 一次指针跳转；  
若 key 是密集整数，**`std::vector<Value>` 或 `absl::flat_hash_map`**  
cache-friendly，快 2~3 倍。

------------------------------------------------
⑤ 热点查询无锁化——**atomic 哈希条纹**  
读多写极少时，把 map 拆成 64 个分片，每个分片一把 `shared_mutex`，  
读端几乎无竞争，写端只锁一个条纹。

------------------------------------------------
⑥ 终极手段：只读场景 **frozen** / **perfect-hash**  
编译期确定集合 → 用 `frozen::unordered_map` 或 `gperf` 生成 **0 碰撞**  
完美哈希，查询退化成一次数组下标。

------------------------------------------------
一行总结  
> **“先 reserve 防 rehash，再换哈希减碰撞，整数密集用数组，只读上 frozen。”**  
> 按这个顺序改，通常 **reserve + 好哈希** 就能让查询提速 30%~70%，其余手段按需上。

### 实现类 string 的构造函数。。。。。。

```c++
#include <cstring>
#include <utility>
#include <iostream>

class String {
public:
    /* 1. 默认构造：空串 "" */
    String() : m_data(new char[1]) {
        m_data[0] = '\0';
    }

    /* 2. C-字符串构造 */
    String(const char *s) : m_data(new char[std::strlen(s) + 1]) {
        std::strcpy(m_data, s);
    }

    /* 3. 拷贝构造 */
    String(const String &rhs) : m_data(new char[std::strlen(rhs.m_data) + 1]) {
        std::strcpy(m_data, rhs.m_data);
    }

    /* 4. 移动构造 */
    String(String &&rhs) noexcept : m_data(rhs.m_data) {
        rhs.m_data = nullptr;   // 置空源对象
    }

    /* 5. 析构 */
    ~String() {
        delete[] m_data;
    }

    /* 打印方便测试 */
    friend std::ostream &operator<<(std::ostream &os, const String &s) {
        return os << (s.m_data ? s.m_data : "(null)");
    }

private:
    char *m_data;   // 题目给定成员名
};

/* -------------- 测试 -------------- */
int main() {
    String s1;                     // 默认
    String s2("hello");
    String s3(s2);                 // 拷贝
    String s4(std::move(s3));      // 移动
    std::cout << s2 << ' ' << s4 << '\n';
}
```

### 递归判断回文

```c++
#include <iostream>
#include <string>

bool isPalindrome(const std::string& s, int l, int r)
{
    if (l >= r) return true;          // 基本情况
    if (s[l] != s[r]) return false;   // 首尾不同
    return isPalindrome(s, l + 1, r - 1); // 递归中间
}

int main()
{
    std::string s;
    std::getline(std::cin, s);
    std::cout << (isPalindrome(s, 0, s.size() - 1) ? "true\n" : "false\n");
    return 0;
}
```

### 交易平台不定时收到Tick数据，通过 Strategy 的 OnTick 函数 推送给 Strategy

下面给出一个**最小可运行**的 C++17 示例，演示  
“交易平台不定时收到 Tick → 通过 `Strategy::OnTick` 推送给策略” 的完整链路。  

代码分三部分：  
1. Tick 数据结构  
2. 策略基类 / 具体策略  
3. 模拟交易所（独立线程随机产生 Tick，并回调策略）

--------------------------------------------------
文件结构
```
tick_strategy.cpp     // 单文件即可编译
```
--------------------------------------------------
tick_strategy.cpp
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <atomic>
#include <chrono>
#include <random>
#include <functional>

//---------- 1. 数据 ----------
struct Tick
{
    std::string symbol;      // 合约代码
    double price = 0;        // 最新价
    long   volume = 0;       // 本次成交量
    std::chrono::system_clock::time_point ts; // 交易所时间
};

//---------- 2. 策略 ----------
class Strategy
{
public:
    virtual ~Strategy() = default;
    virtual void OnTick(const Tick& tick) = 0;   // 纯虚，由用户实现
};

// 示例策略：价格突破 100 就买，低于 95 就卖
class DemoStrategy : public Strategy
{
public:
    void OnTick(const Tick& tick) override
    {
        std::lock_guard<std::mutex> lk(io_);
        if (tick.price > 100.0)
            std::cout << "[Strategy] Buy  @ " << tick.price << std::endl;
        else if (tick.price < 95.0)
            std::cout << "[Strategy] Sell @ " << tick.price << std::endl;
    }
private:
    std::mutex io_;  // 保护 cout，避免打印错乱
};

//---------- 3. 模拟交易所 ----------
class SimExchange
{
public:
    // 策略指针交给交易所，交易所负责回调
    explicit SimExchange(Strategy* s) : strategy_(s)
    {
        if (!strategy_) throw std::runtime_error("strategy null");
    }

    // 启动一条后台线程，随机产生 Tick
    void Start()
    {
        running_ = true;
        thd_ = std::thread(&SimExchange::GenTick, this);
    }

    // 优雅退出
    void Stop()
    {
        running_ = false;
        if (thd_.joinable()) thd_.join();
    }

private:
    void GenTick()
    {
        std::mt19937_64 rng(std::random_device{}());
        std::uniform_real_distribution<double> dist_price(90.0, 110.0);
        std::uniform_int_distribution<int>     dist_vol(1, 100);
        std::uniform_int_distribution<int>     dist_ms(200, 1000); // 间隔 200~1000 ms

        while (running_)
        {
            Tick t;
            t.symbol = "IF2509";
            t.price  = dist_price(rng);
            t.volume = dist_vol(rng);
            t.ts     = std::chrono::system_clock::now();

            // 推送给策略
            strategy_->OnTick(t);

            // 模拟“不定时”到达
            std::this_thread::sleep_for(std::chrono::milliseconds(dist_ms(rng)));
        }
    }

    Strategy* strategy_;
    std::atomic<bool> running_{false};
    std::thread thd_;
};

//---------- 4. main ----------
int main()
{
    DemoStrategy my_strategy;
    SimExchange exchange(&my_strategy);

    exchange.Start();

    std::cout << "Press Enter to quit...\n";
    std::cin.get();

    exchange.Stop();
    return 0;
}
```

--------------------------------------------------
编译 & 运行（Linux / macOS / Windows-WSL）
```bash
g++ -std=c++17 -O2 tick_strategy.cpp -pthread
./a.out
```

--------------------------------------------------
输出示例（随机）
```
Press Enter to quit...
[Strategy] Sell @ 94.2342
[Strategy] Buy  @ 100.567
[Strategy] Sell @ 94.1234
...
```

--------------------------------------------------
如何迁移到真实环境？
1. 把 `SimExchange::GenTick` 换成**行情 API 的回调**（如 CTP `OnRtnDepthMarketData`、Binance WebSocket、Boost.Beast 等）。  
2. 在 `OnTick` 里调用**下单 API** 即可，注意加锁防止并发。  
3. 用**无锁队列**（`moodycamel::ConcurrentQueue`）把行情线程与策略线程解耦，可进一步降低延迟。  

这个骨架足够小，但能直接扩展到生产级别。祝编码愉快!