4399游戏服务器开发工程师岗位在线笔试。

- ## 10道选择
  
    - LRU最后的缓存排列
    
    - 网络层未丢包，但是RTT波动大，TCP窗口增长缓慢 ，最大原因
    
      > 最大原因：**瓶颈出现在「主机处理路径」**——内核/驱动/网卡的软中断、CPU或内存带宽不足，导致**接收端（或发送端）来不及把数据从内核缓存搬到用户空间/网卡**，于是接收窗口（rwnd）被压得很小，进而抑制了对端的发送窗口，整条连接的**有效窗口（min(cwnd, rwnd)）始终升不上去**。  
      >
      > 虽然网络层本身没有丢包，RTT 却因为**数据在内核/驱动队列里排队**而剧烈抖动，TCP 误以为网络拥塞，收敛 cwnd，最终呈现“窗口增长缓慢、RTT 波动大”的现象。
    
    - **多级反馈队列（MLFQ）**有不同的优先级，发现高优先级队列中的短时CPU的任务频繁饥饿，怎么解决
    
      > 1. **多级反馈队列（MLFQ）**
      >    经典调度算法：
      >
      >    - 新任务先进入最高优先级队列，享受短量子。
      >    - 若用完时间片仍未结束，就降到下一级队列，优先级递减，时间片递增。
      >      短任务很快结束；长任务逐渐“沉”到底层，不会饿死别人，也不会被饿死。
      >
      > 2. 你说得对，是我把题意理解反了。题目说的是：
      >
      >    > **“高优先级队列中的短时CPU任务频繁饥饿”**  
      >    > —— 也就是说，这些短任务本身拿不到CPU，不是低优先级任务饿。
      >
      >    重新梳理一下，这个问题本质上是：
      >
      >    ##### 问题定义（修正版）
      >    在多级反馈队列（MLFQ）中，**短CPU型任务被放在高优先级队列**，但**它们反而频繁饥饿**，即**它们得不到CPU时间**，而不是低优先级任务饿。
      >
      >    ---
      >
      >    ##### 为什么会这样？
      >    高优先级队列的任务反而饥饿，通常是因为：
      >
      >    1. **高优先级队列中有大量长CPU任务**，它们持续占用CPU，导致后面的短任务排队很久。
      >    2. **时间片设置不合理**：高优先级队列时间片太长，长任务一直跑不完，短任务被堵在后面。
      >    3. **优先级下降机制太激进**：短任务刚跑一点点就被认为是“长任务”，被降优先级，结果反而拿不到CPU。
      >    4. **I/O密集型任务抢占**：高优先级队列里混入了大量I/O密集型任务，它们频繁占用CPU一小会儿就阻塞，导致后面排队的短CPU任务长期被延后。
      >
      >    ---
      >
      >    ##### 正确的解决方案（针对“高优先级短任务饥饿”）
      >
      >    ###### ✅ 方法1：**缩短高优先级队列的时间片**
      >    - **问题**：高优先级队列时间片太长，长任务持续占用CPU。
      >    - **解决**：把高优先级队列的时间片设得非常短（比如2ms），让长任务很快被中断，短任务更快得到调度。
      >
      >    ###### ✅ 方法2：**限制长任务在高优先级队列的累积**
      >    - **问题**：长任务一直待在高优先级队列，堵住短任务。
      >    - **解决**：设置规则：如果一个任务在高优先级队列用完一个完整时间片还没结束，就立即降级到低优先级队列，避免堵住短任务。
      >
      >    ###### ✅ 方法3：**为短任务设置专用“快速通道”**
      >    - **问题**：高优先级队列混杂了长短任务，短任务被长任务堵住。
      >    - **解决**：单独设立一个“超短任务队列”（比如时间片1ms，只允许运行时间<5ms的任务），短任务直接进入这个队列，避免和长任务竞争。
      >
      >    ###### ✅ 方法4：**防止I/O密集型任务挤占高优先级队列**
      >    - **问题**：I/O密集型任务频繁抢占CPU后阻塞，导致短CPU任务长期等待。
      >    - **解决**：对I/O密集型任务单独设队列，或者限制它们在高优先级队列的停留时间。
      >
      >    ---
      >
      >    ##### 总结一句话
      >    **高优先级短任务饥饿的核心原因，是高优先级队列被“假短任务”（实际是长任务或I/O任务）堵住了。**  
      >    解决的关键是：**快速识别并踢出这些长任务，让真正的短任务尽快跑完。**
    
    - 数据初始顺序基本无序，要求高性能，选择快速排序的原因
      
        + 最坏时间复杂度优于堆排序
        
        + 分治处理有利于并行
        
        + 平均时间复杂度低
    
    - 1个长度为3的八进制数，前导可0，数中奇数个1出现的概率是多少
    
      > ### 问题重述
      > 我们需要计算：  
      > 一个**长度为3的八进制数**（每位取值为0～7，允许前导0），其中**数字“1”出现奇数次**的概率是多少？
      >
      > ### 八进制数的结构
      > - 长度：3位，每位独立，取值范围为0～7（共8种可能）。
      > - 总的可能数：\( 8^3 = 512 \)（每位8种，共3位）。
      >
      > ### 数字“1”出现奇数次的定义
      > - 奇数次：1次或3次（因为最多3位）。
      > - 需要统计：
      >   1. 恰好出现1次“1”的情况。
      >   2. 恰好出现3次“1”的情况。
      >
      > ### 计算每种情况
      > #### 1. 恰好出现1次“1”
      > - 选择哪一位是“1”：\( \binom{3}{1} = 3 \)种位置。
      > - 其余两位不能是“1”（每位有7种选择，0～7除去1）。
      > - 总数：\( 3 \times 7 \times 7 = 147 \)。
      >
      > #### 2. 恰好出现3次“1”
      > - 所有三位都是“1”：只有1种情况（111）。
      > - 总数：1。
      >
      > #### 总有利情况
      > \( 147 + 1 = 148 \)。
      >
      > ### 计算概率
      > 概率 = 有利情况 / 总情况 = \( \frac{148}{512} \)。
      >
      > ### 约分
      > \[
      > \frac{148}{512} = \frac{37}{128} \approx 0.2890625
      > \]
      >
      > ### 最终答案
      > 概率为 \( \frac{37}{128} \)（或约28.90625%）。
    
- ## 编程题
    
    1. 一个小时内活跃用户数最多的开始时间 - 统计每个时间段内不同用户的出现次数（即活跃用户数）（小红书上也有。。。。。。）
    
       > 题型：滑动窗口
       >
       > 下面给出完整 C++ 实现，满足：
       >
       > - 输入：若干行 `user_id, yyyy-mm-dd HH:MM:SS`  
       > - 输出：一小时内活跃用户数最多的开始时间（yyyy-mm-dd HH:MM:SS）。  
       >   如有并列，输出最早时间。
       >
       > 思路  
       > 1. 把每条记录解析成 `(unix_timestamp, user_id)`，按时间排序。  
       > 2. 滑动窗口 + `unordered_map` 统计窗口内用户出现次数；  
       >    保持窗口长度 < 3600 s，同时记录最大用户数对应的最早开始时间。  
       > 3. 复杂度：排序 `O(N log N)`，滑动窗口 `O(N)`，空间 `O(N)`。
       >
       > 代码
       >
       > ```cpp
       > #include <bits/stdc++.h>
       > using namespace std;
       > 
       > struct Record {
       >     long long ts;   // seconds since epoch
       >     string uid;
       > };
       > 
       > /* ---------- 字符串 → unix 时间戳 ---------- */
       > long long toSeconds(const string& dt) {
       >     int y, m, d, H, M, S;
       >     sscanf(dt.c_str(), "%d-%d-%d %d:%d:%d", &y, &m, &d, &H, &M, &S);
       >     tm tm_{};
       >     tm_.tm_year = y - 1900;
       >     tm_.tm_mon  = m - 1;
       >     tm_.tm_mday = d;
       >     tm_.tm_hour = H;
       >     tm_.tm_min  = M;
       >     tm_.tm_sec  = S;
       >     return mktime(&tm_);
       > }
       > 
       > /* ---------- 主逻辑 ---------- */
       > string mostActiveHourStart(vector<Record>& rec) {
       >     if (rec.empty()) return "";
       > 
       >     sort(rec.begin(), rec.end(),
       >          [](const Record& a, const Record& b) { return a.ts < b.ts; });
       > 
       >     unordered_map<string, int> cnt;
       >     size_t left = 0;
       >     int maxUsers = 0;
       >     long long bestStart = rec[0].ts;
       > 
       >     for (size_t right = 0; right < rec.size(); ++right) {
       >         const auto& r = rec[right];
       >         if (++cnt[r.uid] == 1) {          // 新用户
       >             int users = (int)cnt.size();
       >             if (users > maxUsers) {
       >                 maxUsers = users;
       >                 bestStart = rec[left].ts;
       >             } else if (users == maxUsers && rec[left].ts < bestStart) {
       >                 bestStart = rec[left].ts;
       >             }
       >         }
       > 
       >         /* 窗口长度 ≥ 3600 秒，收缩左指针 */
       >         while (rec[right].ts - rec[left].ts >= 3600) {
       >             const auto& l = rec[left];
       >             if (--cnt[l.uid] == 0) cnt.erase(l.uid);
       >             ++left;
       >             if (!cnt.empty()) {
       >                 int users = (int)cnt.size();
       >                 if (users > maxUsers) {
       >                     maxUsers = users;
       >                     bestStart = rec[left].ts;
       >                 } else if (users == maxUsers && rec[left].ts < bestStart) {
       >                     bestStart = rec[left].ts;
       >                 }
       >             }
       >         }
       >     }
       > 
       >     /* 时间戳 → 字符串 */
       >     char buf[20];
       >     tm* ptm = localtime(&bestStart);
       >     strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm);
       >     return buf;
       > }
       > 
       > /* ---------- 读取输入 ---------- */
       > int main() {
       >     ios::sync_with_stdio(false);
       >     cin.tie(nullptr);
       > 
       >     vector<Record> rec;
       >     string line;
       >     while (getline(cin, line)) {
       >         if (line.empty()) continue;
       >         size_t comma = line.find(',');
       >         string uid   = line.substr(0, comma);
       >         string dtStr = line.substr(comma + 2);          // 跳过 ", "
       >         rec.push_back({toSeconds(dtStr), uid});
       >     }
       > 
       >     cout << mostActiveHourStart(rec) << endl;
       >     return 0;
       > }
       > ```
       >
       > 编译运行  
       > ```bash
       > g++ -std=c++17 -O2 active.cpp -o active
       > ./active
       > # 逐行输入，最后 Ctrl+D 结束
       > ```
       >
       > 示例输入  
       > ```
       > U1, 2025-08-25 08:10:00
       > U2, 2025-08-25 08:30:00
       > U1, 2025-08-25 09:00:00
       > U3, 2025-08-25 09:10:00
       > ```
       > 输出  
       > ```
       > 2025-08-25 08:10:00
       > ```
    
    2. 黄金矿工体力 k 内最多能取多少黄金，要求：站在起点消耗一点体力 每走一步消耗 1 点体力，而且必须从有黄金的格子出发，经过的格子也必须有黄金，也就是必须不为0
    
       > 题目类型：图——回溯DFS
       >
       > 下面给出 C++ 版本的完整实现。  
       > 题目要点回顾：
       >
       > - 必须从某个 gold>0 的格子出发；  
       > - 站在起点消耗 1 体力，之后每走一步再消耗 1 体力，因此最多可走 k-1 步；  
       > - 经过的格子必须 gold>0（不能为 0）；  
       > - 每个格子的黄金只能采一次；  
       > - 求 k 体力内能采到的最大黄金量。
       >
       > 代码采用回溯 DFS，对四个方向剪枝，并用「临时置 0 + 回溯恢复」的方式标记已采格子。
       >
       > ```cpp
       > #include <bits/stdc++.h>
       > using namespace std;
       > 
       > /* ---------- 解析器：把形如 [[1,2],[3,4],[5,6]], K = 5 的字符串读进来 ---------- */
       > void parseInput(const string& line,
       >                 vector<vector<int>>& grid,
       >                 int& k)
       > {
       >     size_t bracket = line.find('[');
       >     size_t comma   = line.find("], K = ");
       >     if (bracket == string::npos || comma == string::npos) return;
       > 
       >     /* -------------- 解析 K -------------- */
       >     k = stoi(line.substr(comma + 7));
       > 
       >     /* -------------- 解析 A -------------- */
       >     string arr = line.substr(bracket, comma - bracket + 1);
       >     arr.erase(remove(arr.begin(), arr.end(), ' '), arr.end());
       > 
       >     grid.clear();
       >     vector<int> curRow;
       >     int num = 0;
       >     bool neg = false, inNum = false;
       >     for (char c : arr) {
       >         if (c == '[') continue;
       >         if (c == '-' && !inNum) { neg = true; continue; }
       >         if (isdigit(c)) {
       >             num = num * 10 + (c - '0');
       >             inNum = true;
       >         } else if (c == ',' || c == ']') {
       >             if (inNum) {
       >                 curRow.push_back(neg ? -num : num);
       >                 num = 0; neg = false; inNum = false;
       >             }
       >             if (c == ']') {
       >                 if (!curRow.empty()) {
       >                     grid.push_back(curRow);
       >                     curRow.clear();
       >                 }
       >             }
       >         }
       >     }
       > }
       > 
       > /* ---------- 题目核心算法 ---------- */
       > class Solution {
       > public:
       >     int getMaximumGold(vector<vector<int>>& grid, int k) {
       >         if (grid.empty() || grid[0].empty() || k <= 0) return 0;
       >         int m = grid.size(), n = grid[0].size(), ans = 0;
       >         const int dx[4] = {-1,1,0,0};
       >         const int dy[4] = {0,0,-1,1};
       > 
       >         function<int(int,int,int)> dfs = [&](int x,int y,int left)->int{
       >             if (left < 0) return 0;
       >             int val = grid[x][y];
       >             int best = val;
       >             grid[x][y] = 0;
       >             for (int d=0; d<4; ++d) {
       >                 int nx = x + dx[d], ny = y + dy[d];
       >                 if (nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]>0)
       >                     best = max(best, val + dfs(nx,ny,left-1));
       >             }
       >             grid[x][y] = val;
       >             return best;
       >         };
       > 
       >         for (int i=0;i<m;++i)
       >             for (int j=0;j<n;++j)
       >                 if (grid[i][j]>0)
       >                     ans = max(ans, dfs(i,j,k-1));
       >         return ans;
       >     }
       > };
       > 
       > /* ---------- 主程序：一行输入一行输出 ---------- */
       > int main() {
       >     ios::sync_with_stdio(false);
       >     cin.tie(nullptr);
       >     string line;
       >     getline(cin, line);          // 读整行
       > 
       >     vector<vector<int>> A;
       >     int K;
       >     parseInput(line, A, K);
       > 
       >     Solution sol;
       >     cout << sol.getMaximumGold(A, K) << '\n';
       >     return 0;
       > }
       > ```
       >
       > 复杂度  
       >
       > - 时间：最坏 O(4^{k-1} · m · n)。  
       > - 空间：递归深度 O(k)。
    
    3. 小明玩游戏，N种印章，抽到的印章可重复，有m种礼物，没种礼物需要若干印章兑换，问最多可以兑换多少礼物（后来发现小红书上有原题。。。。。。）
    
       > 题型：动态规划背包
       >
       > 题意澄清  
       > - 共有 N 种印章，每种印章数量 **有限且已知**（数组 `have[N]`）。  
       > - 有 m 种礼物，每种礼物只能用一次；兑换第 i 种礼物需要若干张各类印章（二维数组 `need[m][N]`）。  
       > - 问：在印章 **不可重复利用** 的前提下，**最多能兑换多少种礼物**（不要求知道具体方案，只要求数量）。
       >
       > 解题思路  
       > 把“兑换礼物”看成 N 维背包问题：  
       > - 维度：印章种类 0 … N-1  
       > - 容量：各维印章剩余数量 `have[0..N-1]`  
       > - 物品：第 i 种礼物，体积为 `need[i][0..N-1]`，价值 1（因为只计数）。  
       > - 目标：在总容量限制下，选若干物品使总价值最大。
       >
       > 由于 N ≤ 20，可把每维容量离散化后做 **状态压缩 DP**。  
       > 状态用一个 `int64` 或 `bitset` 记录 **各维剩余印章数** 显然不可行（容量可到 1e9）。  
       > 经典做法：**逐维背包**（分层 DP）。
       >
       > 实现要点  
       > 1. 将 `have[i]` 作为第 i 维容量，礼物作为物品。  
       > 2. 用 `vector<int>` 或 `array<int,N>` 作为状态。  
       > 3. 滚动数组优化，一层一层转移，复杂度 `O(m * have[0] * have[1] * … * have[N-1])`，  
       >    在 N≤20 且各维容量 ≤ 1000 时，最坏 1000^20 爆炸。  
       > 4. **关键优化**：  
       >    - 若 N≤10 且各维容量 ≤ 1000，可状压；  
       >    - 否则采用 **贪心 + 排序**：按“印章需求字典序”或“需求总和”升序排序后，能选就选。  
       >    经证明，**贪心在一般情况不成立**，但题目常见数据范围 N≤10，容量≤1000 时可过。
       >
       > 下面给出 **N≤10，各维容量≤1000** 的 **逐维背包** 代码（可 AC 常见题测）。
       >
       > 代码（逐维背包，N≤10，容量≤1000）
       >
       > ```cpp
       > #include <bits/stdc++.h>
       > using namespace std;
       > 
       > int main() {
       >     ios::sync_with_stdio(false);
       >     cin.tie(nullptr);
       > 
       >     int N, m;
       >     cin >> N >> m;
       >     vector<int> have(N);
       >     for (int i = 0; i < N; ++i) cin >> have[i];
       > 
       >     vector<vector<int>> need(m, vector<int>(N));
       >     for (int i = 0; i < m; ++i)
       >         for (int j = 0; j < N; ++j)
       >             cin >> need[i][j];
       > 
       >     /* 逐维背包：dp[c0][c1]...[c{N-1}] = 已选礼物数 */
       >     vector<int> sz = have;
       >     vector<int> dp(1, 0);      // 初始只有 (0,0,...,0) 状态
       >     for (int c : sz) dp.resize(dp.size() * (c + 1), -1);
       >     dp[0] = 0;
       > 
       >     auto idx = [&](const vector<int>& v) -> int {
       >         int id = 0;
       >         for (int i = 0; i < N; ++i)
       >             id = id * (have[i] + 1) + v[i];
       >         return id;
       >     };
       > 
       >     for (int i = 0; i < m; ++i) {
       >         const auto& v = need[i];
       >         /* 倒序枚举所有状态，防止重复转移 */
       >         vector<int> cur(N);
       >         for (int id = (int)dp.size() - 1; id >= 0; --id) {
       >             if (dp[id] == -1) continue;
       >             /* 解码 id → cur[0..N-1] */
       >             int tmp = id;
       >             bool ok = true;
       >             for (int k = N - 1; k >= 0; --k) {
       >                 cur[k] = tmp % (have[k] + 1);
       >                 tmp /= have[k] + 1;
       >                 if (cur[k] + v[k] > have[k]) { ok = false; break; }
       >             }
       >             if (!ok) continue;
       >             int nid = id;
       >             int base = 1;
       >             for (int k = N - 1; k >= 0; --k) {
       >                 nid += v[k] * base;
       >                 base *= have[k] + 1;
       >             }
       >             if (dp[nid] < dp[id] + 1)
       >                 dp[nid] = dp[id] + 1;
       >         }
       >     }
       > 
       >     cout << *max_element(dp.begin(), dp.end()) << '\n';
       >     return 0;
       > }
       > ```
       >
       > 输入格式  
       > ```
       > N m
       > have[0] have[1] ... have[N-1]
       > need[0][0] need[0][1] ... need[0][N-1]
       > need[1][0] need[1][1] ... need[1][N-1]
       > ...
       > need[m-1][0] ... need[m-1][N-1]
       > ```
       >
       > 示例  
       > ```
       > 2 3
       > 5 5
       > 1 1
       > 2 2
       > 3 3
       > ```
       > 输出  
       > ```
       > 2
       > ```
       > 解释：先选礼物 0 和 1，用掉 3+3=6 ≤ 10，礼物 2 无法选，答案 2。
    
- 感悟题
    1. 你大学最有成就的事是什么，收获了什么
    2. 你如何理解积极主动的含义，列举例子说明

