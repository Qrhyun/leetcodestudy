## 笔试

#### 以太网从插入网线到连上 internet 的过程

#### 将具体地址的寄存器的某一 bit 设置为 1，或清 0，其他比特不变用宏地方式实现 

> ##### 1U 的含义
>
> - `1`：普通的整数字面量，类型是 `int`（有符号整数）
> - `1U`：无符号整数字面量，类型是 `unsigned int`
> - `U` 是 **无符号（Unsigned）** 的标识符
>
> ##### 最常用的简洁写法
>
> ```c++
> // 设置寄存器的某一位为1（置位）
> #define SET_BIT(reg, bit)    ((reg) |= (1U << (bit)))
> 
> // 清除寄存器的某一位为0（清零）
> #define CLEAR_BIT(reg, bit)  ((reg) &= ~(1U << (bit)))
> 
> // 切换寄存器的某一位（取反）
> #define TOGGLE_BIT(reg, bit) ((reg) ^= (1U << (bit)))
> 
> // 检查寄存器的某一位是否为1
> #define CHECK_BIT(reg, bit)  ((reg) & (1U << (bit)))
> ```
>
> ##### 直接操作地址的版本
>
> ```c
> // 直接操作地址的宏
> #define SET_BIT_ADDR(addr, bit)    (*(volatile uint32_t *)(addr) |= (1U << (bit)))
> #define CLEAR_BIT_ADDR(addr, bit)  (*(volatile uint32_t *)(addr) &= ~(1U << (bit)))
> 
> // 使用示例
> #define STATUS_REGISTER 0x40021000
> 
> int main() {
>     SET_BIT_ADDR(STATUS_REGISTER, 3);   // 设置第3位
>     CLEAR_BIT_ADDR(STATUS_REGISTER, 5); // 清除第5位
>     return 0;
> }
> ```
>
> ##### 支持不同位宽的版本
>
> ```c
> // 8位寄存器操作
> #define SET_BIT_8(reg, bit)    ((reg) |= (1U << (bit)))
> #define CLEAR_BIT_8(reg, bit)  ((reg) &= ~(1U << (bit)))
> 
> // 16位寄存器操作  
> #define SET_BIT_16(reg, bit)   ((reg) |= (1U << (bit)))
> #define CLEAR_BIT_16(reg, bit) ((reg) &= ~(1U << (bit)))
> 
> // 32位寄存器操作
> #define SET_BIT_32(reg, bit)   ((reg) |= (1U << (bit)))
> #define CLEAR_BIT_32(reg, bit) ((reg) &= ~(1U << (bit)))
> ```
>
> ##### 带参数检查的安全版本
>
> ```c
> // 带位范围检查的宏
> #define SET_BIT_SAFE(reg, bit) \
>     do { \
>         static_assert((bit) < 32, "Bit position must be 0-31"); \
>         (reg) |= (1U << (bit)); \
>     } while(0)
> 
> #define CLEAR_BIT_SAFE(reg, bit) \
>     do { \
>         static_assert((bit) < 32, "Bit position must be 0-31"); \
>         (reg) &= ~(1U << (bit)); \
>     } while(0)

### 双向链表 a-z 正序插入链表 倒序打印

```go
package main

import "fmt"

// 双向链表节点
type Node struct {
    data rune           // 存储字符
    prev *Node          // 指向前一个节点
    next *Node          // 指向后一个节点
}

// 双向链表
type DoublyLinkedList struct {
    head *Node          // 头节点
    tail *Node          // 尾节点
}

// 正序插入（按字母顺序 a-z）
func (list *DoublyLinkedList) InsertInOrder(char rune) {
    newNode := &Node{data: char}
    
    // 如果链表为空，直接插入
    if list.head == nil {
        list.head = newNode
        list.tail = newNode
        return
    }
    
    // 如果新字符小于头节点，插入到头部
    if char < list.head.data {
        newNode.next = list.head
        list.head.prev = newNode
        list.head = newNode
        return
    }
    
    // 遍历找到合适的插入位置
    current := list.head
    for current.next != nil && current.next.data < char {
        current = current.next
    }
    
    // 插入到当前位置之后
    newNode.next = current.next
    newNode.prev = current
    
    if current.next != nil {
        current.next.prev = newNode
    } else {
        // 如果插入到尾部，更新尾节点
        list.tail = newNode
    }
    current.next = newNode
}

// 倒序打印（从尾到头）
func (list *DoublyLinkedList) PrintReverse() {
    if list.tail == nil {
        fmt.Println("链表为空")
        return
    }
    
    current := list.tail
    for current != nil {
        fmt.Printf("%c ", current.data)
        current = current.prev
    }
    fmt.Println()
}

// 正序打印（从头到尾，用于验证）
func (list *DoublyLinkedList) PrintForward() {
    if list.head == nil {
        fmt.Println("链表为空")
        return
    }
    
    current := list.head
    for current != nil {
        fmt.Printf("%c ", current.data)
        current = current.next
    }
    fmt.Println()
}

func main() {
    list := &DoublyLinkedList{}
    
    // 正序插入字母（顺序是乱的，但会按a-z排序插入）
    letters := []rune{'z', 'a', 'm', 'd', 'f', 'b', 'x', 'c'}
    
    fmt.Println("原始插入顺序:")
    for _, char := range letters {
        fmt.Printf("%c ", char)
    }
    fmt.Println("\n")
    
    // 插入所有字母
    for _, char := range letters {
        list.InsertInOrder(char)
    }
    
    fmt.Println("正序排列后的链表:")
    list.PrintForward()
    
    fmt.Println("\n倒序打印链表:")
    list.PrintReverse()
}
```

### 1 到 100000 之间的质数

```c
#include <stdio.h>

int isPrime(int num) {
    if (num <= 1) {
        return 0;
    }
    if (num == 2) {
        return 1;
    }
    if (num % 2 == 0) {
        return 0;
    }
    
    // 手动计算平方根的近似值
    int i = 1;
    while (i * i <= num) {
        i++;
    }
    int sqrtNum = i - 1;
    
    for (int i = 3; i <= sqrtNum; i += 2) {
        if (num % i == 0) {
            return 0;
        }
    }
    return 1;
}

int main() {
    int count = 0;
    int limit = 100000;
    
    printf("1到100000之间的质数有：\n");
    
    // 单独处理2
    if (limit >= 2) {
        printf("%d ", 2);
        count++;
    }
    
    for (int i = 3; i <= limit; i += 2) {
        if (isPrime(i)) {
            printf("%d ", i);
            count++;
            // 每输出10个质数换行
            if (count % 10 == 0) {
                printf("\n");
            }
        }
    }
    
    printf("\n\n总共找到 %d 个质数\n", count);
    return 0;
}
```

### 递增有序数组被旋转多次，即从中间某位置断开，前后调换， 找出数组中最小值所在的下标 用最少次数寻找 c 语言

```c
#include <stdio.h>

int findMinIndex(int arr[], int n) {
    if (n == 0) return -1;
    if (n == 1) return 0;
    
    int left = 0;
    int right = n - 1;
    
    // 如果数组没有旋转（完全有序）
    if (arr[left] < arr[right]) {
        return 0;
    }
    
    while (left <= right) {
        // 处理只剩两个元素的情况
        if (right - left == 1) {
            return arr[left] < arr[right] ? left : right;
        }
        
        int mid = left + (right - left) / 2;
        
        // 检查mid是否是转折点（最小值位置）
        if (mid > 0 && arr[mid] < arr[mid - 1]) {
            return mid;
        }
        if (mid < n - 1 && arr[mid] > arr[mid + 1]) {
            return mid + 1;
        }
        
        // 决定搜索方向
        if (arr[mid] > arr[right]) {
            // 最小值在右半部分（mid右侧）
            left = mid + 1;
        } else if (arr[mid] < arr[left]) {
            // 最小值在左半部分（mid左侧）
            right = mid - 1;
        } else {
            // 特殊情况：arr[left] == arr[mid] == arr[right]
            // 需要线性搜索（处理重复元素的情况）
            int min_index = left;
            for (int i = left + 1; i <= right; i++) {
                if (arr[i] < arr[min_index]) {
                    min_index = i;
                }
            }
            return min_index;
        }
    }
    
    return left;
}

// 处理可能包含重复元素的版本
int findMinIndexWithDuplicates(int arr[], int n) {
    if (n == 0) return -1;
    if (n == 1) return 0;
    
    int left = 0;
    int right = n - 1;
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] > arr[right]) {
            // 最小值在右半部分
            left = mid + 1;
        } else if (arr[mid] < arr[right]) {
            // 最小值在左半部分（包括mid）
            right = mid;
        } else {
            // 当arr[mid] == arr[right]时，无法判断，右边界减1
            right--;
        }
    }
    
    return left;
}

// 测试函数
int main() {
    // 测试多次旋转的情况
    int test_cases[][10] = {
        {4, 5, 6, 7, 0, 1, 2},          // 旋转1次
        {3, 4, 5, 1, 2},                // 旋转1次
        {6, 7, 0, 1, 2, 3, 4, 5},       // 旋转2次
        {2, 3, 4, 5, 6, 7, 0, 1},       // 旋转3次
        {1, 2, 3, 4, 5},                // 未旋转
        {5, 1, 2, 3, 4},                // 旋转4次
        {0, 1, 2, 3, 4, 5},             // 旋转0次（完全有序）
        {2, 1},                         // 只有两个元素
        {1}                             // 只有一个元素
    };
    
    int sizes[] = {7, 5, 8, 8, 5, 5, 6, 2, 1};
    int test_count = sizeof(sizes) / sizeof(sizes[0]);
    
    for (int i = 0; i < test_count; i++) {
        printf("测试用例 %d: ", i + 1);
        for (int j = 0; j < sizes[i]; j++) {
            printf("%d ", test_cases[i][j]);
        }
        
        int result = findMinIndex(test_cases[i], sizes[i]);
        printf("\n最小值下标: %d, 值: %d\n", result, test_cases[i][result]);
        printf("比较次数: 约 %d 次 (O(log n))\n\n", (int)(log(sizes[i]) / log(2)) + 1);
    }
    
    // 测试包含重复元素的情况
    int arr_with_duplicates[] = {2, 2, 2, 0, 1, 2};
    int n_dup = sizeof(arr_with_duplicates) / sizeof(arr_with_duplicates[0]);
    
    printf("包含重复元素的数组: ");
    for (int i = 0; i < n_dup; i++) printf("%d ", arr_with_duplicates[i]);
    int result_dup = findMinIndexWithDuplicates(arr_with_duplicates, n_dup);
    printf("\n最小值下标: %d, 值: %d\n", result_dup, arr_with_duplicates[result_dup]);
    
    return 0;
}
```

### 0xa1 是几个字节

`0xa1` 是 **1个字节**。

##### 详细解释：

###### 1. **十六进制表示**

- `0x` 前缀表示这是一个十六进制数
- `a1` 是十六进制值，对应二进制：`10100001`

###### 2. **字节大小**

- 1个字节 = 8位
- `0xa1` 正好占用8位二进制，所以是1个字节