# 栈

> 研究的焦点在于栈是可以保存以前的值的，以及栈的功能到底是存储什么这两个问题
> 还有一个是什么时候弹栈，什么时候压栈

## 20.有效的括号

- 最后根据栈的状态开判断结果
- 括号匹配是使用栈解决的经典问题。
- 三种不匹配：
  - 左括号多余.已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以 return false
  - 右括号多余.遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以 return false
  - 括号没有多余，但是顺序不对.遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false
- 用`stack<char> st`来做匹配
- > 第一步：注意下面两句创立一个栈 `stack<char> st`
  > 第二步: 循环里面压栈,作为后面弹栈的工具
  > 第三步：循环里面弹栈和栈顶元素的操作，这部分就是业务处理的重点，根据弹栈或者栈顶元素的匹配与否来决定返回值

```cpp
else if(st.empty() || st.top() != s[i]) return false;
else st.pop();

```

```cpp
class Solution {
public:
    bool isValid(string s) {
        if (s.size() % 2 != 0) return false; // 如果s的长度为奇数，一定不符合要求
        stack<char> st;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') st.push(')');
            else if (s[i] == '{') st.push('}');
            else if (s[i] == '[') st.push(']');
            // 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false
            // 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false
            else if (st.empty() || st.top() != s[i]) return false;
            else st.pop(); // st.top() 与 s[i]相等，栈弹出元素
        }
        // 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true
        return st.empty();
    }
};
```

## 1047 删除字符串中的所有相邻重复项

- 最后栈存的也是最终的结果
- 如何记录前面遍历过的元素呢？用栈来存放，那么栈的目的，就是存放遍历过的元素，当遍历当前的这个元素的时候，去栈里看一下我们是不是遍历过相同数值的相邻元素。

```cpp
class Solution {
public:
    string removeDuplicates(string s) {
        // 1.键栈
        stack<char> st;
        // 2.遍历字符串,并执行消除操作
        for (int i = 0; i < s.size(); i++) {
            if (st.empty() || s[i] != st.top()) {
                // 这里要把st.empty()放在前面，否则会出现段错误，保证代码的健壮性
                st.push(s[i]);
            } else {
                st.pop();
            }
        }
        // 3.将栈中的元素转换为字符串
        string result = ""; // std::string 是一个动态字符串类，初始化为 ""
                            // 表示它是一个空字符串。
        while (!st.empty()) {
            // 判断为空时候，用while比for循环好
            result +=
                st.top(); // std::string 支持使用 += 运算符来拼接字符或字符串。
            st.pop();
        }
        // 4.反转字符串
        reverse(
            result.begin(),
            result
                .end()); // begin() 和 end() 是 C++ 标准库容器（如
                         // std::string, std::vector, std::deque
                         // 等）提供的成员函数，用于获取容器的迭代器范围。它们定义在
                         // <string>、<vector> 等容器对应的头文件中。
        return result;
    }
};
```

## 150. 逆波兰表达式求值

- 栈中存放的是最后的计算结果
- 本题注意的三点的是：
  > 当无法区分各种字符如何区别表示的话，就用死办法一个一个写出来
  > `tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*"  || tokens[i] == "/"`
  > 第二点是赋初值不用斟酌赋初值是 0，还是 1，用` long long num1 = st.top();``long long result = st.top(); `栈会自个儿存
  > 第三点注意栈中的顺序和弹栈的顺序和正常书写的顺序

```cpp
class Solution {
public:
    long long evalRPN(vector<string>& tokens) {
        stack<long long> a;

        for(int i = 0; i<tokens.size(); i++){
            if(tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*"  || tokens[i] == "/" ){
                long long temp1 = a.top(); a.pop();
                long long temp2 = a.top(); a.pop();
                if(tokens[i] == "+") {a.push(temp1+temp2);}
                else if(tokens[i] == "-") {a.push(temp2-temp1);}
                else if(tokens[i] == "*") {a.push((long long)temp1*temp2);} //这里就可以
                else {a.push(temp2/temp1);}
            }else{
                a.push(stoll(tokens[i])); //这里注意stack<long long> a; vector<string>& tokens ，用于将字符串转换为长长整型（long long）数值
                //a.push((long long)tokens[i]);//这里不可以
            }
        }
        return a.top();
        a.pop();
    }
};
```

# 队列

> - 队列的研究焦点在于队列是先进先出的数据结构，队列中存放的也是最终的元素
> - 还有一个是什么时候入队，什么是时候出队。这里入队出队最终保证的就是队列中存放的是最终的元素

## 239.滑动窗口最大值

> 向前滑动的时候要做下面的两件事

- pop(value)：如果窗口移除的元素 value 等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作
- push(value)：如果 push 的元素 value 大于入口元素的数值，那么就将队列入口的元素弹出，直到 push 元素的数值小于等于队列入口元素的数值为止
  > 一些注意点：
- 使用`deque双端队列`实现本题自定义的单调队列`MyQueue`最为合适
- 这个是单调队列，底层是双端队列，所以有`push_front() push_back() pop_front() pop_back()  front()  back() empty()` 这样的 7 个操作
- 对于`vector<>`压的操作是`push_back()`

```cpp
class Solution {
private:
    class MyQueue { //单调队列（从大到小）
    public:
        deque<int> que; // 使用deque来实现单调队列
        // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。
        // 同时pop之前判断队列当前是否为空。
        void pop(int value) {
            if (!que.empty() && value == que.front()) {
              //这里用if
                que.pop_front();
            }
        }
        // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。
        // 这样就保持了队列里的数值是单调从大到小的了。
        void push(int value) {
            while (!que.empty() && value > que.back()) {
                //这里用while
                que.pop_back();
            }
            que.push_back(value);

        }
        // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。
        int front() {
            return que.front();
        }
    };
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        MyQueue que;
        vector<int> result;
        for (int i = 0; i < k; i++) { // 先将前k的元素放进队列
            que.push(nums[i]);
        }
        result.push_back(que.front()); // result 记录前k的元素的最大值
        for (int i = k; i < nums.size(); i++) {
            que.pop(nums[i - k]); // 滑动窗口移除最前面元素
            que.push(nums[i]); // 滑动窗口前加入最后面的元素
            result.push_back(que.front()); // 记录对应的最大值
        }
        return result;
    }
};
```
