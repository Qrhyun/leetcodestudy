## 101对称二叉树
- 一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。
- 都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了
`递归法`
- 一般要两个函数，一个专门用作递归，一个是主函数，来传入参数调用递归
- 首先排除空节点的情况
- 递归法
```cpp
class Solution {
public:
    bool compare(TreeNode* left, TreeNode* right) {
        // 首先排除空节点的情况
        if (left == NULL && right != NULL) return false;
        else if (left != NULL && right == NULL) return false;
        else if (left == NULL && right == NULL) return true;
        // 排除了空节点，再排除数值不相同的情况
        else if (left->val != right->val) return false;

        // 此时就是：左右节点都不为空，且数值相同的情况
        // 此时才做递归，做下一层的判断
        bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
        bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
        bool isSame = outside && inside;                    // 左子树：中、 右子树：中 （逻辑处理）
        return isSame;

    }
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        return compare(root->left, root->right);
    }
};
```

`迭代法`
```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列
        
        while (!que.empty()) {  // 接下来就要判断这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }

            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};
```

## 104.二叉树的最大深度
`递归法`
> - 本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。
> - 二叉树节点的深度：指从**根节点到该节点**的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）
> - 二叉树节点的高度：指从**该节点到叶子节点**的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）
> - 而根节点的高度就是二叉树的最大深度，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度。
```cpp
class Solution {
public:
    int getdepth(TreeNode *node) {
        if(node == NULL) return 0;
        int leftdepth = getdepth(node->left);
        int rightdepth = getdepth(node->right);
        if(leftdepth >= rightdepth) return leftdepth + 1;
        else return rightdepth+1;
    }
    int maxDepth(TreeNode* root) {
        int result = getdepth(root);
        return result;
    }
};
```
`迭代法`
- 使用迭代法的话，使用层序遍历是最为合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。
- 在二叉树中，一层一层的来遍历二叉树，记录一下遍历的层数就是二叉树的深度
```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        int result = 0;
        queue<TreeNode *> que;
        if (root == NULL) return 0;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            result++;
            for(int i = 0; i < size; i++){
                TreeNode *temp = que.front();
                que.pop();
                if(temp->left) que.push(temp->left);
                if(temp->right) que.push(temp->right);
            }
        }
    return result;
    }
}; 
```
## 111.二叉树的最小深度
`递归法`
`错误答案`
```cpp
class Solution {
public:
    int getdepth(TreeNode *node) {
        if (node == NULL) return 0;
        int leftdepth = getdepth(node->left);
        int rightdepth = getdepth(node->right);
        if(leftdepth <= rightdepth) return leftdepth + 1;
        else return rightdepth + 1;

    }
    int minDepth(TreeNode* root) {
        return getdepth(root);
    }
};
```
- 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。注意是叶子节点。
- 什么是叶子节点，左右孩子都为空的节点才是叶子节点！
- 所以说这里需要加入判断
```cpp
class Solution {
public:
    int getdepth(TreeNode* node) {
        if (node == NULL)
            return 0;
        int leftdepth = getdepth(node->left);
        int rightdepth = getdepth(node->right);

        if (node->left == NULL && node->right != NULL) {
            return 1 + rightdepth;
        }
        if (node->right == NULL && node->left != NULL) {
            return 1 + leftdepth;
        }

        return 1 + min(leftdepth, rightdepth);
    }
    int minDepth(TreeNode* root) { return getdepth(root); }
};
```
`迭代法`
- 需要注意的是，只有当左右孩子都为空的时候，才说明遍历到最低点了。如果其中一个孩子不为空则不是最低点
```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {
        int result = 0;
        queue<TreeNode *> que;
        if (root == NULL) return 0;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            result++;
            for(int i = 0; i < size; i++){
                TreeNode *temp = que.front();
                if(temp->left == NULL && temp->right == NULL){
                   return result;
                }
                que.pop();
                if(temp->left) que.push(temp->left);
                if(temp->right) que.push(temp->right);
            }
        }
    return result;
    }
}; 
```